; https://archive.org/details/ataridiskutilities/page/n1/mode/2up
; [ entries in brackets are comments added in transcribing from the scan ]
; [lots of transcribing errors are likely; the original scan is low resolution]
; [note: DOS is 0700-12FF and is not included in the listings]
; [note: Scans of the pages often appear to cut off the last line of text]

; [cover page]
;
; [stamp:]
; ATARI PRELIMINARY CONFIDENTIAL
;
; [handwritten:]
; 1 of 10
;
; DISK UTILITIES
;
; [cursive handwriting, not fully legible:] Sent To Gary

;SYSRES	=	0	***USER RAM RESIDENT VERSION ***
SYSRES	=	1	***SYSTEM RAM RESIDENT VERSION ***
CIO	=	$E456
DKHND	=	$E453
SETVBV	=	$E45C
SYSVBV	=	$E45F
XITVBV	=	$E462
MEMTOP	=	$2E5
IRGEN	=	$D20E
BRKKEY	=	$11
POKMSK	=	$10
DOSVEC	=	$A
WARMST	=	8
CARTST	=	$BFFA
MEMLO	=	$2E7
SHFLOK	=	$2BE
RUNAD	=	$2E0
ICHIDZ	=	$20
ICDNOZ	=	$21
ICBALZ	=	$24
ICBAHZ	=	$25
ICIDNO	=	$2E
MAXDEV	=	$21
HATABS	=	$31A
;CIO SUBROUTINES
COMENT	=	$E63D
GOHAND	=	$E689
DEVSRC	=	$E69E
	.TITLE	"COLLEEN DISK UTILITIES"
;
;
;
;***********************************************************************
;		FILENAME =DK1:DUPV.SRC
;***********************************************************************
;
;	DISK UTILITY ROUTINE FOR COLLEEN D.B.
;
HILO	.MACRO	&1
&1H	=	&1/256
&1L	=	-256*&1H+&1
	.ENDM
;
;
;	ZERO PAGE VARIABLES
;
	*=$18
JMPTBL	*=*+2
RAMLO	*=*+2
;
;
;
;
;
;
USRDOS	=	$1700
FMS	=	$700
FMINIT	=	FMS+$88
; [end of page cut off slightly]
; [equate used below is probably here]
DOS	=	$1300
;


	.IF	SYSRES
	*=DOS
	LDA	#DOSOSL
	STA	DOSVEC
	LDA	#DOSOSH
	STA	DOSVEC+1
	JSR	FMINIT
	LDA	WARMST	ON COLDSTART, LOAD AUTO.SYS
	BNE	INITX
	LDA	#AFL
	STA	ICBAL+$10
	LDA	#AFH
	STA	ICBAH+$10
LOADV	JMP	LOAD	LOAD VECTOR, ALSO INIT LOAD AND EXIT.
INITX	RTS
AF	.BYTE	"D1:AUTO.SYS",CR
	HILO	AF
;[equates are shown in listing but generated by above macro:]
AFH	=	AF/256
AFL	=	-256*AFH+AF
	.ENDIF
	.IF	SYSRES-1
	*=USRDOS
LOADV	=	$1319
	.ENDIF
;
CR	=	$9B
CUP	=	$1C
CDN	=	$1D
CLF	=	$1E
CRT	=	$1F
DLL	=	$9C
CLSCR	=	$7D
;
;
OPEN	=	$03
CLOSE	=	$0C
PUTCHR	=	$0A
GETCHR	=	$06
GETRCD	=	$04
PUTRCD	=	$08
RENAME	=	$20
DELETE	=	$21
FORMAT	=	$FE
LOCK	=	$23
UNLOCK	=	$24
;
TEXT	=	1
;
;
DCB	=	$300
DUNIT	=	DCB+1
DCOMND	=	DCB+2
DSTATS	=	DCB+3
DBUFLO	=	DCB+4
DBUFHI	=	DCB+5
DSLO	=	DCB+$A

DSHI	=	DCB+$B
;
IOCB	=	$340
ICHID	=	IOCB+0
ICDNO	=	IOCB+1
ICCOM	=	IOCB+2
ICSTA	=	IOCB+3
ICBAL	=	IOCB+4
ICBAH	=	IOCB+5
ICBLL	=	IOCB+8
ICBLH	=	IOCB+9
ICAX1	=	IOCB+10
ICAX2	=	IOCB+11
PAR	*=*+40	PARAMETER AREA [1329]
PARH	=	PAR/256
PARL	=	-256*PARH+PAR
LINE	*=*+80	TYPEIN LINE BUFFER [1351]
LBUFH	=	LINE/256
LBUFL	=	-256*LBUFH+LINE
DBUF	*=*+$100	DATA BUFFER FOR COPY
DB1	=	DBUF+$80
DB3	=	DBUF-3
	HILO	DBUF
DBUFH	=	DBUF/256
DBUFL	=	-256*DBUFH+DBUF
	HILO	DB1
DB1H	=	DB1/256
DB1L	=	-256*DB1H+DB1
	HILO	DB3
DB3H	=	DB3/256
DB3L	=	-256*DB3H+DB3
DBLL	=	0
DBLH	=	1	DATA BUFFER LENGTH=$100
MENUSZ	*=*+1
PER	*=*+1
UNNO	*=*+1
RCNT	*=*+1
SSTAT	*=*+1
SWDP	*=*+5
CSRC	*=*+1
CDES	*=*+1
SAVX	*=*+1
PTR	*=*+1
IPTR	*=*+1
CTR	*=*+1
OPT	*=*+1
T1	*=*+2
STVEC	*=*+2	A TEMP OF SOME KIND
MNA	*=*+2	MENU ADDRESS
MNL	*=*+2	MENU LENGTH
RDM	*=*+1	FF TO REDISPLAY MENU
DTH	=*
	HILO	DTH
DTHH	=	DTH/256
DTHL	=	-256*DTHH+DTH
LDST	*=*+2
LDND	*=*+2
;
;

SAVH	.BYTE	$84,$09
	HILO	SAVH
SAVHH	=	SAVH/256
SAVHL	=	-256*SAVHH+SAVH
EDN	.BYTE	"E:",CR
EDH	=	EDN/256
EDL	=	-256*EDH+EDN
KDN	.BYTE	"K:",CR
	HILO	KDN
KDNH	=	KDN/256
KDNL	=	-256*KDNH+KDN
;
;
DMENU	.BYTE	CLSCR
	.BYTE	"DISK OPERATING SYSTEM   9/24/79",CR
	.BYTE	"COPYRIGHT 1979 ATARI",CR,CR
	.BYTE	"A. DISK DIRECTORY I. FORMAT DISK",CR
	.BYTE	"B. RUN CARTRIDGE  J. DUPLICATE DISK",CR
	.BYTE	"C. COPY FILE      K. BINARY SAVE",CR
	.BYTE	"D. DELETE FILE(S) L. BINARY LOAD",CR
	.BYTE	"E. RENAME FILE    M. RUN AT ADDRESS",CR
	.BYTE	"F. LOCK FILE      N. DEFINE DEVICE",CR
	.BYTE	"G. UNLOCK FILE    O. DUPLICATE FILE",CR
	.BYTE	"H. WRITE DOS FILE",CR

	.BYTE	CDN,CDN,CDN,CDN,CDN
DMEND	=*
DULEN	=	DMEND-DMENU
	HILO	DULEN
DULENH	=	DULEN/256
DULENL	=	-256*DULENH+DULEN
	HILO	DMENU
DMENUH	=	DMENU/256
DMENUL	=	-256*DMENUH+DMENU
;
DUJPT	.WORD	DIRLST,STCAR,CPYFIL,DELFIL,RENFIL,LKFIL,ULFIL
	.WORD	WBOOT,FMTDSK,DUPDSK,SAVFIL,LDFIL,BRUN,DEFDEV
	.WORD	DUPFIL
	HILO	DUJPT
DUJPTH	=	DUJPT/256
DUJPTL	=	-256*DUJPTH+DUJPT
DUNUM	=	15	NUMBER OF FUNCTIONS
;
;
;***********************************************************************
;	DISK UTILITY ROUTINE STARTS HERE
;***********************************************************************
;
;
;
;
;
;
;	DISK OPERATING SYS MONITOR
;
DOSOS	LDA	#$FF
	HILO	DOSOS
DOSOSH	=	DOSOS/256
DOSOSL	=	-256*DOSOSH+DOSOS
	STA	BRKKEY
	STA	WARMST
	LDA	POKMSK	ENABLE BREAK INTERRUPTS
	ORA	#$80
	STA	POKMSK
	STA	IRGEN
	JSR	INITIO	CLOSE FILES
	LDA	#OPEN
	STA	ICCOM+$30	K: IOCB [IOCB3+2]
	LDX	#$30	K: IOCB
	LDA	#$04
	STA	ICAX1,X	OPEN READ
	LDA	#KDNH
	STA	ICBAH,X	[IOCB0+5,X]
	LDA	#KDNL
	STA	ICBAL,X	[IOCB0+4,X]
	JSR	CIO	[line missing from listing]

;
;	DISK UTILITY MONITOR
;
DSKUTL
DUI	LDA	#DUNUM
	STA	MENUSZ	SET MENU SIZE
	LDA	#DUJPTL
	STA	JMPTBL
	LDA	#DUJPTH
	STA	JMPTBL+1	SET UP JUMP TABLE ADDRESS
	LDA	#DMENUL
	STA	MNA	SET UP FOR MENU COPY
	LDA	#DMENUH
	STA	MNA+1
	LDA	#DULENL
	STA	MNL
	LDA	#DULENH
	STA	MNL+1
; FAL LTHRU TO MENU SELECT
;
;
;
;	MENU SELECT MONITOR -- VECTORS TO ROUTINE SELECTED FROM MENU.
;
SHMEN	LDA	#0	CLEAR PAUSE AND SHOW MENU FLAG
	STA	RDM
	LDA	MNA
	STA	ICBAL
	LDA	MNA+1
	STA	ICBAH
	LDA	MNL
	STA	ICBLL
	LDA	MNL+1
	STA	ICBLH
	JSR	DSPMSG	SHOW MENU
;
;	SELECT ITEM FROM MENU
;	FUNCTION COME HERE WHEN THEY ARE DONE.
;
MENUSL	LDX	#$FF	RESET STACK AT THIS POINT
	TXS
	BIT	RDM	IF WE SHOULD SHOW MENU
	BMI	PBMEN	GO DO IT
	LDA	#SITL	SELECT ITEM MESSAGE
	LDX	#SITH
	JSR	DSPLIN
	LDA	#$40	MAKE SURE UPPER CASE
	STA	SHFLOK
	JSR	CHRGET		GO GE KEYBOARD CHAR.
	SEC
	SBC	#'A		CONVERT ASCII CHAR. TO BINARY # & SUBTRACT 1
	BMI	RANGE		IF ASCII CHAR NOT  3, GO READ AGAIN
	CMP	MENUSZ		IS THE # ENTERED > MENU SIZE?
	BPL	RANGE		IF YES, GO READ AGAIN
	ASL	A
	TAY			SET INDEX TO (MENU # - 1) * 2
	LDA	(JMPTBL),Y
	INY
	STA	RAMLO	GET STRING POINTER
	LDA	(JMPTBL),Y

	STA	RAMLO+1
	LDY	#1	LOAD STRING POINTER INTO REGISTERS
	LDA	(RAMLO),Y	FOR DSPLIN
	TAX
	DEY
	LDA	(RAMLO),Y
	JSR	DSPLIN	PRINT MODULES INITIAL STRING
	LDA	RAMLO	INC BY 2 TO POINT PAST STRING POINTER
	CLC
	ADC	#2
	STA	RAMLO
	LDA	RAMLO+1
	ADC	#0	CARRY
	STA	RAMLO+1	PUT HI BYTE.
	JMP	(RAMLO)	JUMP TO ROUTINE SELECTED BY MENU.
RANGE	LDA	#NBIL
	LDX	#NBIH
	JSR	DSPLIN	NO SUCH ITEM MESSAGE
	JMP	MENUSL
NBI	.BYTE	"NO SUCH ITEM",CR
SIT	.BYTE	"SELECT ITEM",CR
	HILO	NBI
NBIH	=	NBI/256
NBIL	=	-256*NBIH+NBI
	HILO	SIT
SITH	=	SIT/256
SITL	=	-256*SITH+SIT
MNSL	=	MENUSL
	HILO	MNSL
MNSLH	=	MNSL/256
MNSLL	=	-256*MNSLH+MNSL
;
; PAUSE AND REDISPLAY MENU
;
PBMEN	LDA	#0
	STA	ICBLH
	LDA	#21
	STA	ICBLL
	LDA	#PMESH
	STA	ICBAH
	LDA	#PMESL
	STA	ICBAL
	JSR	DSPMSG
	JSR	CHRGET
	JMP	SHMEN
PMES	.BYTE	CR,"TYPE RETURN FOR MENU"
	HILO	PMES

PMESH	=	PMES/256
PMESL	=	-256*PMESH+PMES
;
;
;	DIRECTORY LISTING ROUTINE
;
DIRLST	.WORD	DLMG
	JSR	GETICI
	LDX	PTR
	LDA	#CR
	STA	PAR-1,X	ASSURE GOOD TERM
	LDA	PAR-2,X	LAST CHAR OF SEARCH SPEC
	CMP	#':	IF COLON, ADD *.*
	BNE	DLF
	LDA	#'*
	STA	PAR-1,X
	STA	PAR+1,X
	LDA	#'.
	STA	PAR,X
	LDA	#CR
	STA	PAR+2,X
	INX
	INX
	INX
	STX	PTR
DLF	STX	SAVX
	LDX	#$20
	JSR	PIOCB
	JSR	GETFIL
	JSR	PERX
	LDA	#6	READ DIR INFO
	LDX	#$10
	STA	ICAX1,X
	LDA	#OPEN	OPEN
	STA	ICCOM,X
	STX	CSRC	COPY SOURCE=DIRECTORY INFO
	CPX	#$10
	BNE	*+3	[BUG! Wanted to skip 3 bytes, only skips 1]
	JSR	CIOCL	[20 C2 23; execute 2-byte undocumented C2 NOP opcode]
	LDA	PTR
	SEC
	SBC	SAVX
	CMP	#3	IF ONLY 3 CHARS; IS "D:"CR, USE DEFAULT
	BEQ	DLST1
DLST0	JMP	PDES	GO INTO COPY
DLST1	LDX	SAVX
	LDA	PAR,X
	CMP	#'D
	BNE	DLST0
	JMP	PDES1	GO INTO COPY WITH DEB='E:'
DLMG	.BYTE	"DIRECTORY--SEARCH SPEC,LIST FILE?",CR

DELFIL	.WORD	DEMG
	JSR	GETICI
	JSR	PERX	EXIT IF PARAM ERRORS
	LDA	PAR	GET DEVICE
	CMP	#'D	ONLY ALLOW DELETE FROM D:
	BEQ	DF1
	LDA	#NDFL
	LDX	#NDFH
	JSR	DSPLIN
	JMP	MENUSL
NDF	.BYTE	"NOT A DISK FILE",CR
	HILO	NDF
NDFH	=	NDF/256
NDFL	=	-256*NDFH+NDF
DF1	LDX	#$10
	LDA	OPT
	CMP	#'N	IF OPTION=N, NO QUERY
	BNE	DNO	NO DELETE WITH QUERY
	LDA	#DELETE
	STA	ICCOM,X
	JSR	CIOCL
	JMP	MENUSL
DNO	LDA	#TYDL
	LDX	#TYDH
	JSR	DSPLIN	SAY Y TO DELETE
	LDA	#0
	STA	IPTR	HOW MANY FILES TO SKIP, NONE AT FIRST
	LDX	#$20	SET UP DELETE IOCB
	LDA	#DELETE
	STA	ICCOM,X
	LDA	#DB3L
	STA	ICBAL,X
	LDA	#DB3H
	STA	ICBAH,X
	LDA	#'D
	STA	DBUF-3
	LDA	#':
	STA	DBUF-1
	LDA	PAR+1
	CMP	#':
	BNE	*+4
	LDA	#'1
	STA	DBUF-2	KLUDGE KLUDGE KLUDGE
IDRD	LDX	#$10
	LDA	#$03

	STA	ICCOM,X
	LDA	#6
	STA	ICAX1,X	DIR READ OPEN
	LDA	#PARL
	STA	ICBAL,X
	LDA	#PARH
	STA	ICBAH,X
	JSR	CIOCL
	LDA	#DBUFL
	STA	ICBAL,X
	LDA	#DBUFH
	STA	ICBAH,X
	LDA	#GETRCD
	STA	ICCOM,X
	LDA	#0
	STA	PTR	HOW MANY FILES WE HAVE SKIPPED
; READ FILENAME FROM DIR, QUERY AND DELETE
RDFN	LDX	#$10
	LDA	#0
	STA	ICBLL,X
	LDA	#1
	STA	ICBLH,X
	JSR	CIOCL	READ A LINE FROM DIRECTORY
	LDA	DBUF+1	IF FILE LINE, THIS IS BLANK
	CMP	#' 
	BNE	DELX	THIS IS FREE BLOCKS LINE
	INC	PTR	COUNT THIS FILE
	LDA	PTR	HAVE WE SKIPPED ENUF YET
	CMP	IPTR
	BMI	RDFN	BR IF NO
	LDX	#0	PUT PTR
	LDY	#2	GET PTR
; MASSAGE DELETE FILE NAMES
MDN1	LDA	DBUF,Y
	CMP	#' 	END OF FILENAME
	BEQ	MDN2
	STA	DBUF,X
	INX
	INY
	CPX	#8
	BMI	MDN1
;FILENAME IS MOVED, PUT .EXT
MDN2	LDA	#'.
	STA	DBUF,X
	INX
	LDY	#10	WHERE EXT IS
MDN3	LDA	DBUF,Y
	STA	DBUF,X
	INY
	INX
	CPY	#13
	BMI	MDN3
	STX	SAVX	PUT CR HERE LATER .
	LDA	#'?	FOR QUERY
	STA	DBUF,X
	INX
	LDA	#CR
	; [ next three instructions missing from bottom of page]
	STA	DBUF,X
	LDA	#DB3L
	LDX	#DB3H

	JSR	DSPLIN	GO ASK ABOUT THIS FILE
	JSR	CHRGET
	CMP	#$59
	BNE	RDFN	GO DO NEXT FILENAME
	LDA	PTR	NUMBER FILES WE HAVE GONE THRU SO FAR
	STA	IPTR	IS NEW NUMBER TO SKIP
	LDX	SAVX
	LDA	#CR
	STA	DBUF,X
	LDX	#$20	DELETE IOCB
	JSR	CIOCL
	JSR	CLOS1
	JMP	IDRD	CLOSE AND REOPEN DIR READ FILE
DELX	JSR	CLOS1	CLOSE DIR READ FILE
	JMP	MENUSL
CLOS1	LDX	#$10
	LDA	#CLOSE
	STA	ICCOM,X
	JSR	CIOCL
	RTS
TYD	.BYTE	"TYPE ",$22,"Y",$22," TO DELETE...",CR
	HILO	TYD
TYDH	=	TYD/256
TYDL	=	-256*TYDH+TYD
DEMG	.BYTE	"DELETE FILE SPEC",CR
;***************
;
;
;	COPY FILE ROUTINE
;***************
CPMG	.BYTE	"COPY--FROM, TO?",CR
DE	.BYTE	"OPTION DOESNT MAKE SENSE",CR
	HILO	DE
DEH	=	DE/256

DEL	=	-256*DEH+DE
CPYFIL	.WORD	CPMG
	JSR	GETICI
	LDA	OPT
	PHA
	LDX	PTR
	DEX
	LDA	#CR	TERM FIRST FILENAME
	STA	PAR,X
	LDX	#$20	IOCB 3
	JSR	PIOCB
	LDA	PTR
	STA	SAVX
	JSR	GETFIL	GET SECOND FILENAME
	JSR	PERX	IF PARAM ERRS, EXIT
PSRC	PLA
	TAX
	LDA	PAR	GET 1ST LETR OF PARAM
	CMP	#'K	K AND E AS SOURCE ARE SPECIAL
	BEQ	ODMS	K: GETS 'OPTION DOESNT MAKE SENSE' FOR NOW
	CMP	#'E
	BNE	OPSRC	IF NO THEN OPEN SOURCE FILE
	DEC	RDM	E: SO RESHOW MENU AFTER COPY
	LDX	#0
	STX	CSRC
	JMP	PDES
OPSRC	CMP	#'S
	BEQ	ODMS	S: AS SOURCE GETS O.D.M.B. FOR NOW
	CPX	#'S
	BNE	OPSRC1
	CMP	#'C
	BNE	ODMS
	LDA	#$80
	STA	ICAX2+$10
OPSRC1	LDX	#$10
	LDA	#OPEN
	STA	ICCOM,X
	LDA	#4	OPEN IN
	STA	ICAX1,X
	STX	CSRC
	CPX	#$10
	BNE	*+33	[OPSRCX - JMP MENUSL]
	JSR	CIOCL	OPEN SOURCE FILE HERE
PDES	LDX	SAVX
	LDA	PAR,X
	CMP	#'E	CHECK FOR SPECIAL CASE
	BNE	OPDES	IF NOT
PDES1	LDA	#0	SPECIAL CASE - DONT OPEN, USE EXISTING IOCB
	STA	CDES
	DEC	RDM	SET FLAG TO RESHOW MENU
	JMP	DOCPY
ODMS	LDA	#DEL
	LDX	#DEH
	JSR	DSPLIN
OPSRCX	JMP	MENUSL	[label added]
OPDES	CPX	#'A	APPEND TO DISK FILE
	BNE	OPDES1
	CMP	#'D
	BNE	ODMS
	LDA	#$09

	BNE	OPDES3
OPDES1	LDA	#8
OPDES3	LDX	#$20
	STA	ICAX1,X	OPEN TYPE OUT
	LDA	#OPEN
	STA	ICCOM,X	OPEN
	STX	CDES
	JSR	CIOCL
	LDA	#0
	STA	ICAX2,X
;COPY FROM CSRC TO CDES
DOCPY	LDA	#GETCHR+TEXT
	LDX	CSRC
	LDY	CDES
	STA	ICCOM,X
	LDA	#PUTCHR+TEXT
	STA	ICCOM,Y
	LDA	#DBUFL
	STA	ICBAL,X
	STA	ICBAL,Y
	LDA	#DBUFH
	STA	ICBAH,X
	STA	ICBAH,Y
CLOOP	LDX	CSRC
	LDA	#$00
	STA	ICBLL,X
	LDA	#$01
	STA	ICBLH,X
	JSR	CIO	READ FROM INPUT
	STY	SSTAT
	LDX	CDES
	LDY	CSRC
	LDA	ICBLL,Y
	STA	ICBLL,X
	LDA	ICBLH,Y
	STA	ICBLH,X
	ORA	ICBLL,Y	IF SOURCE FILE LENGTH = 0
	BEQ	CKRS	DONT DO WRITE
	JSR	CIOCL	WRITE, ABORT IF ERROR
CKRS	LDA	SSTAT	GET READ OPERATION STATUS BACK
	BPL	CLOOP	IF OK, GO READ SOME MORE
	CMP	#$88	EOF STATUS
	BEQ	*+5
	JMP	CIOER	IF NOT, ABORT
CLOC	LDX	CSRC
	BEQ	DU4	IF E:, DONT CLOSE
	CPX	#$30	OR K:
	BEQ	DU4
	LDA	#CLOSE
	STA	ICCOM,X
	JSR	CIO
DU4	LDX	CDES
	BEQ	DU3	IF DES=E:
	LDA	#CLOSE
	STA	ICCOM,X
	JSR	CIO
DU3	JMP	MENUSL
;***************
;

;	RENAME FILE ROUTINE
;
;***************
RENFIL	.WORD	RNMG
	JSR	GETICI
	JSR	GETNAME
	JSR	PERX
	LDA	#RENAME
	LDX	#$10
	STA	ICCOM,X
	JSR	CIOCL
	JMP	MENUSL
RNMG	.BYTE	"RENAME, GIVE OLD NAME, NEW",CR
;***************
;
;
;
;
;	FORMAT DISK ROUTINE
;
;***************
FMTDSK	.WORD	WHD
	JSR	GETLIN
	JSR	GETDN
	CLC
	ADC	#'0
	STA	DDSK
	STA	CDSK
	JSR	PERX
	LDA	#VFML	QUERY TO VERIFY DRIVE NUMBER
	LDX	#VFMH
	JSR	DSPLIN
	JSR	CHRGET
	CMP	#'Y	SEE IF OK
	BNE	FMX
	LDA	#FDPL
	LDX	#$10
	STA	ICBAL,X
	LDA	#FDPH
	STA	ICBAH,X
	LDA	#FORMAT
	STA	ICCOM,X
	JSR	CIOCL	CALL CIO TO DO FORMAT
FMX	JMP	MENUSL	EXIT
WHD	.BYTE	"WHICH DRIVE TO FORMAT?",CR

VFM	.BYTE	"TYPE ",$22,"Y",$22," TO FORMAT DISK "
DDSK	*=*+1	[save a byte for the drive number, '2' in my binary]
	.BYTE	CR
FDP	.BYTE	"D"
CDSK	*=*+1	[save a byte for the drive number, '2' in my binary]
	.BYTE	":",CR
	HILO	WHD
WHDH	=	WHD/256
WHDL	=	-256*WHDH+WHD
	HILO	VFM
VFMH	=	VFM/256
VFML	=	-256*VFMH+VFM
	HILO	FDP
FDPH	=	FDP/256
FDPL	=	-256*FDPH+FDP
;***************
;
;	START CART ROUTINE
;
;***************
SYVBL	=	SYSVBV
	HILO	SYVBL
SYVBLH	=	SYVBL/256
SYVBLL	=	-256*SYVBLH+SYVBL
XTVBL	=	XITVBV
	HILO	XTVBL
XTVBLH	=	XTVBL/256
XTVBLL	=	-256*XTVBLH+XTVBL
STCAR	.WORD	SCMG
	LDA	$BFFC	SEE IF CART
	BEQ	ISCAR	GO IF THERE IS
	LDA	#NCAL
	LDX	#NCAH	SAY NO CART
	JSR	DSPLIN
	JMP	MENUSL
ISCAR	JSR	INITIO
; 	RESET VERTICAL BLANK VECTORS BEFORE ENTERING CART
	LDA	#6	SET VVBLKI
	LDX	#SYVBLH	HI BYTE
	LDY	#SYVBLL
	JSR	SETVBV
	LDA	#7	SET VVBLKD
	LDX	#XTVBLH
	LDY	#XTVBLL
	JSR	SETVBV
	JMP	(CARTST)
NCA	.BYTE	"NO CARTRIDGE",CR
	HILO	NCA
NCAH	=	NCA/256

NCAL	=	-256*NCAH+NCA
SCMG	.BYTE	CR
;
;
BRUN	.WORD	BRMG
	JSR	GETLIN
	JSR	GETNO
	JSR	PERX
	STA	RAMLO
	STX	RAMLO+1
	JMP	(RAMLO)
BRMG	.BYTE	"RUN FROM WHAT ADDRESS?",CR
;
; DEFINE DEVICE
;
DEDE	.BYTE	"LOGICAL DEVICE, PHYSICAL DEVICE?",CR
DEFDEV	.WORD	DEDE
	JSR	GETLIN
	JSR	GETFIL	GET LOGICAL DEVICE NAME
	LDA	PTR
	CMP	#3	SHOULD BE DEVICE NAME ONLY
	BNE	BS1	BAD SYNTAX
	JSR	GETFIL	GET PHYSICAL DEVICE
	JSR	PERX
	LDA	PAR	GET LOG DEV
	JSR	HATS	SEARCH HAT (HANDLER ADDRESS TABLE)
	BPL	DD1	IF FOUND
;DIDNT FIND IT SO FIND EMPTY SLOT
	LDA	#0
	JSR	HATS
	BMI	STF	TABLE IS FILLED
	LDA	PAR
	STA	HATABS,X  PUT NAME IN TABLE
DD1	LDA	#DRHL
	STA	HATABS+1,X
	LDA	#DRHH
	STA	HATABS+2,X
	STX	SAVX
;SET UP LDNT,PDST ENTRIES
	LDA	PAR	GET DEVICE
	JSR	FLDB
	BPL	SV1	IF FOUND IT

	LDA	#0
	JSR	FLDB
	BPL	SV2
;NO ROOM IN TABLE
STF	LDA	#TFL
	LDX	#TFH
DSX	JSR	DSPLIN
	JMP	MENUSL
TF	.BYTE	"TABLE FULL",CR\
	HILO	TF
TFH	=	TF/256
TFL	=	-256*TFH+TF
BS2
BS1
	LDA	#BSML
	LDX	#BSMH
	BNE	DSX
BSM	.BYTE	"CANT DEFINE THIS DEVICE",CR
	HILO	BSM
BSMH	=	BSM/256
BSML	=	-256*BSMH+BSM
SV2	LDA	PAR
	STA	LDNT,X
;SEE NOW IF THIS IS A DELETE
SV1	LDA	PAR+2
	CMP	#CR
	BNE	CRD	NO, GO CREATE DEVICE
;DELETE OPERATION, ZERO LDNT AND HAT ENTRIES
	LDA	#0
	STA	LDNT,X
	LDX	SAVX
	STA	HATABS,X
	JMP	MENUSL
;CREATE DEVICE - HAT AND LDNT ARE SET UP, MAKE PDST ENTRY
CRD	TXA
	ASL	A
	ASL	A
	ASL	A
	ASL	A
	TAX
	LDY	#0
CPSL	LDA	PAR+3,Y	GET BYTE OF PHYSICAL DEV:FILESPEC
	STA	PDST,X	STORE IN TABLE
	INX
	INY
	CPY	#16
	BNE	CPSL
	JMP	MENUSL
;HATS FINDS DEVICE NAMED IN A, RETURNS ITS INDEX IN X

HATS	LDX	#MAXDEV
HATSL	CMP	HATABS,X
	BEQ	HATX
	DEX
	DEX
	DEX
	BPL	HATSL
HATX	RTS
;FLDB IS THE SAME THING FOR LDNT
FLDB	LDX	#4
FLL	CMP	LDNT,X
	BEQ	FLDX
	DEX
	BPL	FLL
FLDX	RTS
;	
; WBOOT - WRITE OUT NEW DOS.SYS FILE
;	
WBOOT	.WORD	OWMG
	JSR	CHRGET
	CMP	#'Y
	BNE	WBX	EXIT UNLESS Y
	LDA	#WBMGL
	LDX	#WBMGH
	JSR	DSPLIN
	LDA	#OPEN
	LDX	#$10
	STA	ICCOM,X
	LDA	#DSL
	STA	ICBAL,X
	LDA	#DSH
	STA	ICBAH,X
	LDA	#8
	STA	ICAX1,X
	JSR	CIOCL
	LDX	#$10
	LDA	#CLOSE
	STA	ICCOM,X
	JSR	CIOCL
WBX	JMP	MENUSL
WBMG	.BYTE	"WRITING NEW DOS.SYS FILE",CR
	HILO	WBMG
WBMGH	=	WBMG/256
WBMGL	=	-256*WBMGH+WBMG
OWMG	.BYTE	"TYPE ",$22,"Y",$22," TO WRITE NEW DOS FILE",CR

DS	.BYTE	"D:DOS.SYS",CR
	HILO	DS
DSH	=	DS/256
DSL	=	-256*DSH+DS
;
;
;
; LDFIL - LOAD FILE FUNCTION
;
LDFIL	.WORD	LFMG
	LDA	#MNSLL
	STA	RUNAD	SET RUN ADDRESS TO MENU SELECT
	LDA	#MNSLH	SO IF NONE IN FILE WE GO THERE
	STA	RUNAD+1
	JSR	GETICI
	JSR	PERX
	JSR	LOADV
	CPX	#0	PROCESS LOAD SUBR RESPONSE
	BNE	*+5	BR IF ERRORS
	JMP	(RUNAD)
	CPX	#3
	BEQ	NLF	IF BAD LOAD FILE
	TYA		OTHERWISE WE GOT A CIO ERROR
	JMP	CIOER	GO SAW WHAT IT IS
LDFX	JMP	MENUSL
NLF	LDA	#BLFL
	LDX	#BLFH
	JSR	DSPLIN	BAD LOAD FILE MSG
	JSR	CLOSX	CLOSE THE FILE
	JMP	MENUSL	EXIT
BLF	.BYTE	"BAD LOAD FILE",CR
	HILO	BLF
BLFH	=	BLF/256
BLFL	=	-256*BLFH+BLF
LFMG	.BYTE	"LOAD FROM WHAT FILE?",CR
;
; LKFILE - DO CIO LOCK
;
LKFIL	.WORD	LKMG
	JSR	GETICI
	JSR	PERX
	LDA	#LOCK
	LDX	#$10
	STA	ICCOM,X

	JSR	CIOCL
	JMP	MENUSL
LKMG	.BYTE	"WHAT FILE TO LOCK?",CR
;
; ULFIL - DO CIO UNLOCK
ULFIL	.WORD	ULMG
	JSR	GETICI
	JSR	PERX
	LDA	#UNLOCK
	LDX	#$10
	STA	ICCOM,X
	JSR	CIOCL
	JMP	MENUSL
ULMG	.BYTE	"WHAT FILE TO UNLOCK?",CR

DDMG	.BYTE	"DUP DISK-SOURCE,DEST DRIVES?",CR
OK	.BYTE	"TYPE ",$22,"Y",$22," IF OK TO USE PROGRAM AREA",CR
	HILO	OK
OKH	=	OK/256
OKL	=	-256*OKH+OK
;****************
;
;
;
;
;	DUPLICATE DISK ROUTINE
;
;
;*************
;
;	RVTOC READS VOLUME TABLE OF CONTENTS SECTOR
;
RVTOC	LDA	#1
	STA	DSHI	READ VTOC SECTOR
	LDA	#$68
	STA	DSLO
	LDA	#DB1H
	STA	DBUFHI
	LDA	#DB1L
	STA	DBUFLO	POINT DCB AT PAR
	JSR	RSEC1
	LDA	#0
	STA	PTR
	LDA	PAR+$A
	STA	CSRC	BYTE OF ALLOC MAP
	LDA	#8
	STA	IPTR	COUNT BITS IN BYTE
	LDA	#0
	STA	DSHI	POINT T SECTOR ONE
	LDA	#1
	STA	DSLO
	RTS
;
;
; (comment missing from bottom of listing page)
DUPDSK	.WORD	DDMG

	JSR	GETLIN
	JSR	GETDN
	STA	UNNO	UNIT NO FOR READ
	JSR	GETDN
	STA	CDES
	JSR	PERX
	LDA	UNNO
	CMP	CDES	IF BOTH UNITS THE SAME
	BEQ	SDD	SINGLE DRIVE DUP
	LDX	#IBDH
	LDA	#IBDL
	JSR	DSPLIN	PROMPT TO INSERT BOTH DISKS
	JSR	CHRGET
	JSR	RVTOC
NSEC	JSR	AAM	ADV ALLOC MAP ONE BIT
	BMI	CEND
	JSR	RSEC
	LDA	CDES	UNIT TO WRITE TO
	STA	DUNIT
	JSR	DKWAT
CEND	JSR	ASP
	BNE	NSEC	IF MORE SECTORS
	JMP	MENUSL	DONE
IBD	.BYTE	"INSERT BOTH DISKS, TYPE RETURN",CR
	HILO	IBD
IBDH	=	IBD/256
IBDL	=	-256*IBDH+IBD
;SINGLE DRIVE DISK DUP
;
;FIND AVAIL MEMORY, FILL FROM SOURCE DISK, SWAP, EMPTY, SWAP, REPEAT.
;
SDD	LDA	MEMLO	END OF DUP
	STA	STVEC
	LDA	MEMLO+1
	STA	STVEC+1
	LDA	MEMTOP
	SEC
	SBC	#$80	END-128 TO SEE IF ROOM
	STA	T1	FOR ANOTHER SECTOR
	LDA	MEMTOP+1
	SBC	#0
	STA	T1+1
;SEE IF ROOM FOR AT LEAST ONE SECTOR!
	LDA	T1+1
	CMP	STVEC+1
	BMI	NORM
	BNE	ENUF
	LDA	T1
	CMP	STVEC
	BPL	ENUF

NORM	LDA	#NRML
	LDX	#NRMH
	JSR	DSPLIN
	JMP	MENUSL
ENUF	JSR	CKMEM	SEE IF OK TO USE USER AREA
	LDA	#0
	STA	OPT	SET UP FOR READ HERE FIRST PASS
	LDA	#ISDL
	LDX	#ISDH
	JSR	DSPLIN
	JSR	CHRGET
	JSR	RVTOC	READ VTOC AFTER 1ST INSERT SOURCE MSG
	LDA	DSLO	COPY INITIAL WRITE POINTERS
	STA	SWDP	TO INITIAL READ POINTERS
	LDA	DSHI
	STA	SWDP+1
	LDA	PTR
	STA	SWDP+2
	LDA	IPTR
	STA	SWDP+3
	LDA	CSRC
	STA	SWDP+4
	JMP	LRS1	SKIP FIRST READ PROMPT
;READ FROM SOURCE DISK TIL BUF FULL OR END OF DATA
DORD	LDA	#0	FLAG WE ARE READING
	STA	OPT
	LDA	#ISDL	INSERT SRC DISK
	LDX	#ISDH
XBLK	JSR	DSPLIN
	JSR	CHRGET
;SWAP POINTERS TO WHERE WE ARE
LRS1	JSR	DOSWDP	SWAP SECTOR AND BITMAP POINTERS
;LOOP READING/WRITING SECTORS TO BUFFER AREA
LRS	JSR	AAM	ADVANCE ALLOCATION MAP
	BMI	ASPT	IF FREE, ADVANCE SECTOR POINTER AND TRY AGIN
	BIT	OPT	SEE WHAT MODE
	BMI	DOW	BR IF WRITE
	JSR	RSEC1	DO READ
	JMP	IOD
DOW	JSR	DKWAT	DO WRITE
IOD	LDA	DBUFLO	ADVANCE BUFFER POINTER
	CLC
	ADC	#$80
	STA	DBUFLO
	LDA	DBUFHI
	ADC	#$00
	STA	DBUFHI
ASPT	JSR	ASP	GO ADVANCE SECTOR POINTER
	BEQ	STDD1	ALL SECTORS DONE, SWAP TO DEST DISK
	LDA	T1+1	SEE IF ROOM FOR ANOTHER
	CMP	DBUFHI
	BMI	STDD	IF NO ROOM, GO SWAP
	BNE	LRS	ROOM SO CONTINUE
	LDA	T1
	CMP	DBUFLO
	BPL	LRS	ROOM
;SWAP DISKS AND CONTINUE
STDD	LDA	OPT
	BMI	DORD	IF WAS WRITE, GO READ
STDD2	DEC	OPT

	LDA	#IDDL	INSERT DEST DISK
	LDX	#IDDH
	JMP	XBLK	GO DO WRITE
STDD1	LDA	OPT	END OF DATA
	BPL	STDD2	IF READ GO WRITE
	JMP	MENUSL	IF WRITE WE ARE DONE
;DOSWDP - EXCHANGE CURRENT AND SAVED BITMAP&SECTOR POINTERS
; ALSO INIT BUFFER POINTER
DOSWDP	LDY	#4
SWLOP	LDA	SWATL,Y
	STA	RAMLO
	LDA	SWATH,Y
	STA	RAMLO+1	GET ADDRESS FROM TABLE TO RAMLO
	LDX	#0
	LDA	(RAMLO,X)	GET WHATS THERE
	PHA
	LDA	SWDP,Y
	STA	(RAMLO,X)
	PLA
	STA	SWDP,Y
	DEY
	BPL	SWLOP
	LDA	STVEC
	STA	DBUFLO
	LDA	STVEC+1
	STA	DBUFHI
	RTS
;
;	WHAT A MESS
;
	HILO	DSLO
DSLOH	=	DSLO/256
DSLOL	=	-256*DSLOH+DSLO
	HILO	DSHI
DSHIH	=	DSHI/256
DSHIL	=	-256*DSHIH+DSHI
	HILO	PTR
PTRH	=	PTR/256
PTRL	=	-256*PTRH+PTR
	HILO	IPTR
IPTRH	=	IPTR/256
IPTRL	=	-256*IPTRH+IPTR
	HILO	CSRC
CSRCH	=	CSRC/256
CSRCL	=	-256*CSRCH+CSRC
;
SWATL	.BYTE	DSLOL,DSHIL,PTRL,IPTRL,CSRCL
SWATH	.BYTE	DSLOH,DSHIH,PTRH,IPTRH,CSRCH
;
NRM	.BYTE	"NOT ENOUGH ROOM",CR
ISD	.BYTE	"INSERT SOURCE DISK,TYPE RETURN",CR

IDD	.BYTE	"INSERT DESTINATION DISK,TYPE RETURN",CR
	HILO	NRM
NRMH	=	NRM/256
NRML	=	-256*NRMH+NRM
	HILO	ISD
ISDH	=	ISD/256
ISDL	=	-256*ISDH+ISD
	HILO	IDD
IDDH	=	IDD/256
IDDL	=	-256*IDDH+IDD
; AAM - ADVANCE ALLOCATION MAP ONE BIT.
; RETURN MINUS IF FREE.
AAM	ASL	CSRC	NEXT BIT OF ALLOC MAP
	DEC	IPTR
	BNE	CBIT	IF DONE WITH THIS BYTE
	INC	PTR	GET NEXT ONE
	LDX	PTR
	LDA	DB1+$A,X
	STA	CSRC
	LDA	#8
	STA	IPTR
CBIT	LDA	CSRC	CHECK THE BIT
	RTS
; ASP - ADVANCE SECTOR POINTER IN DCB.
; RETURN EQ IF AT END.
ASP	LDA	DSLO	SEE IF END
	CMP	#207
	BNE	NXS
	LDA	DSHI
	CMP	#2
	BEQ	ASPX	ALL DONE
NXS	INC	DSLO
	BNE	ASPX
	INC	DSHI
ASPX	RTS
;
; RSEC - READ A SECTOR WHOSE NUMBER IS IN DCB
;
RSEC	LDA	#DBUFL
	STA	DBUFLO
	LDA	#DBUFH

	STA	DBUFHI
RSEC1	LDA	UNNO
	STA	DUNIT
	LDA	#$52	GET SECTOR
	JMP	CLDKH
;
; DKWRT - WRITE A SECTOR, NUMBER IN DCB
;
DKWAT	LDA	#$57
CLDKH	STA	DCOMND
	LDA	#2	SET RETRY COUNT
	STA	RCNT
CLD1	JSR	DKHND
	LDA	DSTATS
	CMP	#1
	BEQ	DRTS	OK STATUS
	DEC	RCNT
	BPL	CLD1
	JMP	CIOER	CIO ERROR, GO SAY WHICH
DRTS	RTS
;
;	CKMEM - ASK IF OK TO USER USER AREA
;
DDXT	PLA		POP RETURN ADDRESS
	PLA
	JMP	MENUSL
CKMEM	LDA	WARMST	IF MEMORY WAS INTACT
	BEQ	CPTR1	QUERY TO BOMB IT
	LDA	#OKL
	LDX	#OKH
	JSR	DSPLIN
	JSR	CHRGET
	CMP	#'Y
	BNE	DDXT
	LDA	#0
	STA	WARMST
CPTR1	RTS

;
;	DUPFIL - COPY FILE FROM ONE DISK TO ANOTHER
;
DPFM	.BYTE	"NAME OF FILE TO MOVE?",CR
DUPFIL	.WORD	DPFM
	JSR	GETICI	GET A DEV:FILSPEC
	JSR	PERX	CHECK FOR ERRORS
	JSR	CKMEM
	LDX	#$10
	LDA	#OPEN
	STA	ICCOM,X
	LDA	#4
	STA	ICAX1,X
	JSR	CIOCL
	LDA	MEMTOP	SET BUFFER LENGTH
	SEC		TO ALL AVAILABLE MEMORY
	SBC	MEMLO
	STA	ICBLL,X
	LDA	MEMTOP+1
	SBC	MEMLO+1
	STA	ICBLH,X
	LDA	MEMLO
	STA	ICBAL,X
	LDA	MEMLO+1
	STA	ICBAH,X
	LDA	#GETCHR
	STA	ICCOM,X
	JSR	CIO
	CPY	#$88
	BEQ	OKS	IF EOF, WE READ WHOLE FILE SO OK
	CPY	#1
	BEQ	*+5
	JMP	CIOER1	NOT OK OR EOF SO GIVE ERROR MESSAGE
	LDA	#NRML	OK, SAY NO ROOM
	LDX	#NRMH
	JSR	DSPLIN
DFCX	LDA	#CLOSE
	LDX	#$10
	STA	ICCOM,X
	JSR	CIO
	JMP	MENUSL
OKS	LDA	#CLOSE
	LDX	#$10
	STA	ICCOM,X
	LDA	ICBLL,X
	STA	T1
	LDA	ICBLH,X
	STA	T1+1
	JSR	CIO
	LDX	#IDDH
	LDA	#IDDL
	JSR	DSPLIN	SAY TO SWAP DISKS
	JSR	GETLIN

	LDX	#$10
	LDA	#PARL
	STA	ICBAL,X POINT TO FILENAMEAGAIN
	LDA	#PARH
	STA	ICBAH,X
	LDA	#OPEN
	STA	ICCOM,X
	LDA	#8
	STA	ICAX1,X
	JSR	CIOCL	OPEN FOR OUTPUT
	LDA	MEMLO
	STA	ICBAL,X
	LDA	MEMLO+1	SET UP ADR AND LENGTH
	STA	ICBAH,X
	LDA	T1
	STA	ICBLL,X
	LDA	T1+1
	STA	ICBLH,X
	LDA	#PUTCHR
	STA	ICCOM,X
	JSR	CIOCL	DO THE WRITE
	JMP	DFCX	CLOSE AND EXIT
;**************
;
;
;	SAVE FILE ROUTINE
;
;************
SAVFIL	.WORD	SFMG
	JSR	GETICI
	LDA	OPT
	PHA
	LDX	PTR	PUT EOL ON FILENAME
	LDA	#CR
	STA	PAR-1,X
	JSR	GETNO	GET HEX PARAMETER
	STA	LDST
	STX	LDST+1
	JSR	GETNO	END ADDRESS
	STA	LDND
	STX	LDND+1
	BIT	PER	SEE IF PARAM ERRORS
	BPL	*+5
	JMP	MENUSL	IF ERRORS
	LDA	#0
	STA	OPT
	PLA		OPTION CHAR FROM FILENAME
	CMP	#'A	IF APPEND
	BNE	*+5
	DEC	OPT	SET OT=$FF
; OPEN THE FILE
	LDX	#$10
	LDA	#OPEN
	STA	ICCOM,X
	BIT	OPT	IF APPEND
	BMI	*+6
	LDA	#8
	BNE	*+4
	LDA	#9
	STA	ICAX1,X

	JSR	CIOCL
; WRITE SAVE FILE HEADER
	LDX	#$10
	LDA	#PUTCHR
	STA	ICCOM,X
	BIT	OPT	IF APPEND,
	BMI	WDR	DONT WRITE ANOTHER HEADER
	LDA	#SAVHL
	STA	ICBAL,X
	LDA	#SAVHH
	STA	ICBAH,X
	LDA	#2
	STA	ICBLL,X
	LDA	#0
	STA	ICBLH,X
	JSR	CIOCL
; WRITE DATA RECORD
WDR	LDX	#$10
	LDA	#4
	STA	ICBLL,X
	LDA	#0
	STA	ICBLH,X
	LDA	#DTHL	DATA RECORD HEADER
	STA	ICBAL,X
	LDA	#DTHH
	STA	ICBAH,X
	JSR	CIOCL	NO. WRITE DATA REC HDR
	LDX	#$10
	SEC
	LDA	LDND
	SBC	LDST
	STA	ICBLL,X
	LDA	LDND+1
	SBC	LDST+1
	STA	ICBLH,X
	INC	ICBLL,X
	BNE	*+5
	INC	ICBLH,X
	LDA	LDST
	STA	ICBAL,X
	LDA	LDST+1
	STA	ICBAH,X
	JSR	CIOCL	WRITE THE DATA
	LDX	#$10
	LDA	#CLOSE
	STA	ICCOM,X
	JSR	CIOCL
	JMP	MENUSL	DONE
SFMG	.BYTE	"SAVE--GIVE FILE, START, END",CR
;
;		S U B R O U T I N E S
;
;
;
;
; INITIO - CLOSE ANY OPEN IOCBS
;
INITIO	LDX	#$70
IIO1	LDA	ICHID,X
	CMP	#$FF	CHECK FOR CLOSED IOCB
	BEQ	NXIOCB	ALREADY CLOSED, CHECK NEXT ICOB
	LDA	#CLOSE
	STA	ICCOM,X
	JSR	CIO
NXIOCB	TXA
	SEC
	SBC	#$10
	TAX
	BPL	IIO1
	LDX	#0	REOPEN IOCB0 to E:
	LDA	#OPEN
	STA	ICCOM
	LDA	#ECL
	STA	ICBAL
	LDA	#ECH
	STA	ICBAH
	LDA	#$C
	STA	ICAX1,X
	JSR	CIO
	RTS
EC	.BYTE	"E:",CR
	HILO	EC
ECH	=	EC/256
ECL	=	-256*ECH+EC
;
;
GETLIN	LDA	#CR
	LDX	#79
	STA	LINE,X
	DEX
	BPL	*-4
	LDA	#0
	STA	PTR
	STA	IPTR
	STA	PER
	JSR	CIOGET
	JSR	SCROL
	RTS
;
;
;
; CIOGET - GET LINE OF INPUT FROM SCREEN EDITOR
;
CIOGET	LDA	#GETRCD+TEXT
	STA	ICCOM	SCREEN EDIT IOCB
	LDA	#LBUFL
	STA	ICBAL
	LDA	#LBUFH
	STA	ICBAH

	LDA	#80
	STA	ICBLL
	LDA	#0	[could use ASL A to save a byte here]
	STA	ICBLH
	LDX	#0	[could use TAX to save a byte here]
	JSR	CIO	READ RECORD FROM SCREEN EDITOR
	CPY	#$80	CHECK FOR BREAK ABORT STATUS
	BNE	*+5
	DEC	PER	PARAM ERROR FLAG IS SET IF SO
	RTS
CHRGET	LDA	#0
	STA	PER
CHRG1	JSR	CIOGET	GET A LINE FROM E:
	LDA	ICBLL	SAVE CHAR COUNT
	STA	RCNT
	JSR	SCROL
	LDA	PER
	BPL	CHRG2	IF BREAK, CLOSE AND EXIT
	JSR	CLOSX
	JMP	MENUSL
CHRG2	LDA	RCNT	EXPECT 1 OR 2 CHARACTERS
	CMP	#3
	BMI	CHRG3	IF OK
	LDA	#OLL
	LDX	#OLH
	JSR	DSPLIN
	JMP	CHRG1	TRY AGAIN
CHRG3	LDA	LINE	GET 1ST CHAR
	RTS
OL	.BYTE	"PLEASE TYPE 1 LETTER",CR
	HILO	OL
OLH	=	OL/256
OLL	=	-256*OLH+OL
;
; PERX - EXIT IF PARAMETER ERRORS
;
PERX	BIT	PER
	BMI	PERX1
	RTS
PERX1	PLA
	PLA
	JMP	MENUSL
;
; GETCLI - READ LINE, GET FILENAME, POINT TO IT IN IOCB1
;
; [bottom of page cut off in listing]
GETICI	JSR	GETLIN
	LDX	#$10
	JSR	PIOCB
	JSR	GETFIL
	RTS

;
;
GETNAME	LDA	#8
	STA	CTR
	LDY	PTR
	LDX	IPTR
	JMP	CFTE
;
;
;GET FILESPEC FROM INPUT LINE
GETFIL	LDY	PTR
	LDX	IPTR
	LDA	#$0B	[Dissasembly has #$0B, listing as #10.  Which is correct?]
	STA	CTR
;AVOID GETTING JUNK ON VERY SHORT PARAMS
	LDA	LINE,X
	CMP	#',
	BEQ	ADDC
	CMP	#CR
	BEQ	ADDC
	LDA	LINE+1,X
	CMP	#',
	BEQ	GT1
	CMP	#CR
	BEQ	GT1
	LDA	#':	LOOK FOR : IN FILESPEC
	CMP	LINE+2,X	SEE IF HAVE COMPLETE FILESPEC ALREADY
	BEQ	CFTE
	CMP	LINE+1,X
	BNE	GT1
	DEC	CTR
	LDA	LINE,X
	CMP	#'A
	BPL	CFTE	HAVE X:FILE, COMPLETE FILESPEC
;IF FALLS THRU, IS UNIT:FILE, ADD D
GT2	LDA	#'D
	STA	PAR,Y
	INY
	BPL	CFTE
GT1	DEC	CTR
	CMP	LINE,X	AN UNLIKELY CASE (:FILE)
	BEQ	GT2	TREAT :FILE AS D:FILE
	DEC	CTR
ADDC	LDA	#'D
	STA	PAR,Y
	INY
	LDA	#':
	STA	PAR,Y
	INY
CFTE	LDA	#0
	STA	OPT
CFTE1	LDA	LINE,X
	STA	PAR,Y
	INX
	INY
	CMP	#CR	LOOK FOR TERMINATION
	BEQ	EOC
	CMP	#',
	BEQ	EOC
	CMP	#'0-1

	BEQ	POPT
	CMP	#'.	LOOK FOR START OF .EXT
	BNE	CFTE2
	LDA	#4	FOUND, 4 MORE CHARS MAX
	STA	CTR
CFTE2	DEC	CTR
	BPL	CFTE1
;GETS HERE IF TOO MANY CHARS IN FILENAME
	LDA	#NTLL
	LDX	#NTLH
	JSR	DSPLIN	NAME TOO LONG
	DEC	PER	SET PARAMETER ERROR FLAG
STE	LDA	LINE,X  SKIP TO END
	INX
	CMP	#',
	BEQ	EOC
	CMP	#CR
	BNE	STE
EOC	STX	IPTR
	STY	PTR
	RTS
POPT	LDA	LINE,X
	STA	OPT
	INX
	LDA	LINE,X
	STA	PAR-1,Y CHANGE STORED TERMINATOR TO , OR CR I HOPE
	INX
	BPL	EOC
NTL	.BYTE	"NAME TOO LONG",CR
	HILO	NTL
NTLH	=	NTL/256
NTLL	=	-256*NTLH+NTL
;
; DSPMSG - DISPLAY N BYTES
;	BUFFER POINTER AND LENGTH ARE ALREDY IN IOCB0
;
DSPMSG	LDA	#PUTCHR
	STA	ICCOM
	LDX	#0
	JSR	CIO1
	RTS
;
; DSPLIN - DISPLAY ONE LINE OF TEXT
;
DSPLIN	JSR	DSPLI1
	JSR	SCROL
	RTS
;
;
DSPLI1	STA	ICBAL	ADDRESS OF LINE TO IOCB
	STX	ICBAH
	LDA	#PUTRCD+TEXT
	STA	ICCOM
	LDA	#0	SET BUFF LEN
	STA	ICBLH
	LDA	#80

	STA	ICBLL
	LDX	#0
	JSR	CIO1
	RTS
;
CIO1	JSR	CIO	CALL CIO AND GO TO MENUSL
	CPY	#$80	IF BREAK KEY ABORT
	BNE	*+5
	JMP	MENUSL
	RTS
;
; SCROL - DO SCROLLING OF AREA BELOW MENU
;
SCROL	LDA	#0
	TAX
	STA	ICBLH,X
	LDA	#10
	STA	ICBLL,X
	LDA	#ZAPH
	STA	ICBAH,X
	LDA	#ZAPL
	STA	ICBAL,X
	JSR	DSPMSG
	RTS
ZAP	.BYTE	CUP,CUP,CUP,CUP,CUP
	.BYTE	DLL,CDN,CDN,CDN,CDN
	HILO	ZAP
ZAPH	=	ZAP/256
ZAPL	=	-256*ZAPH+ZAP
;
; PIOCB - POINT IOCB AT PAR(PTR)
;
PIOCB	LDA	#PARL
	CLC
	ADC	PTR
	STA	ICBAL,X
	LDA	#PARH
	ADC	#0
	STA	ICBAH,X
	RTS
;
; CIOCL - CALL CIO AND PROCESS ANY ERRORS
;
CIOCL	JSR	CIO	CALL CIO
	TYA
	BMI	*+3	[same as CIOER1]
	RTS		OK, RETURN
CIOER1	TYA		ERROR STATUS
CIOER	SEC
	SBC	#100	ERROR NUMS ALWAYS ARE 1XX DEC
	LDX	#'0-1
CTNS	INX
	SEC
	SBC	#10
	BPL	CTNS	THE EASY (SLOW) WAY
	CLC
	ADC	#10+'0	CONVERT
	STA	EUN

	STX	ETN
	LDX	#CIEH
	LDA	#CIEL
CIEX	JSR	DSPLIN
	JSR	CLOSX	CLOSE IOCBS 10,20
	JMP	MENUSL
CIE	.BYTE	"ERROR-   1"
ETN	.BYTE	0	[In disassembly, '2, as it will change in use]
EUN	.BYTE	0	[In disassembly, '8, as it will change in use]
	.BYTE	CR
	HILO	CIE
CIEH	=	CIE/256
CIEL	=	-256*CIEH+CIE
;
; CLOSX - CLOSE IOCBS 10,20
;
CLOSX	LDA	#CLOSE
	STA	ICCOM+$10
	STA	ICCOM+$20
	LDX	#$10
	JSR	CIO
	LDX	#$20
	JSR	CIO
	RTS
	.IF	SYSRES
;
;
; LOAD - THIS SUBROUTINE
;	   LOADS FROM THE FILE (MUST BE LOAD FORMAT)
;	   INTO MEMORY, RETURNS:
;	 X=0 LOAD OK
;	 X=1 OPEN ERRORS Y=CIO CODE
;	 X=2 READ ERRORS Y=CIO CODE
;	 X=3 BAD LOAD FILE
; ON ENTRY, IOCB 1 POINTS TO FILENAME.
;
LOAD	LDX	#$10
	LDA	#OPEN
	STA	ICCOM,X
	LDA	#4	OPEN TYPE=INPUT
	STA	ICAX1,X
	JSR	CIO	TRY TO OPEN FILE
	BPL	RDLF
	LDA	#1
	BNE	CLFX	CLOSE AND EXIT
RDLF	LDX	#$10
	LDA	#DBUFL
	STA	ICBAL,X
	LDA	#DBUFH
	STA	ICBAH,X
	LDA	#2
	STA	ICBLL,X
	LDA	#0
	STA	ICBLH,X
	LDA	#GETCHR
	STA	ICCOM,X
	JSR	CIO

	BMI	ERST	IF ERRS
	LDA	#$84
	CMP	DBUF	CHECK FOR VALID LOAD FILE
	BNE	LNLF
	LDA	#$09
	CMP	DBUF+1
	BNE	LNLF
RDDRC	LDX	#$10
	LDA	#DBUFL
	STA	ICBAL,X
	LDA	#DBUFH
	STA	ICBAH,X
	LDA	#4
	STA	ICBLL,X
	LDA	#0
	STA	ICBLH,X
	JSR	CIO	NO ERROR CHECK SO CAN CATCH EOF
	BPL	STOK	IF NO ERROR
	CPY	#$88	SEE IF EOF
	BNE	ERST	IF SOME ERROR STATUS
;EOF SO DONE, EXIT
	LDA	#0
CLFX	PHA
	TYA
	PHA
	LDX	#$10
	LDA	#CLOSE
	STA	ICCOM,X
	JSR	CIO
	PLA
	TAY
	PLA
	TAX
	RTS
LNLF	LDA	#3	BAD LOAD FILE
	BNE	CLFX
ERST	LDA	#2	READ ERRS
	BNE	CLFX
STOK	LDX	#$10
	LDA	DBUF	MOVE PARAMS TO IOCB
	STA	ICBAL,X
	LDA	DBUF+1
	STA	ICBAH,X
	LDA	DBUF+2
	SEC
	SBC	DBUF
	STA	ICBLL,X
	LDA	DBUF+3
	SBC	DBUF+1
	STA	ICBLH,X
	INC	ICBLL,X
	BNE	*+5
	INC	ICBLH,X
	JSR	CIO
	BMI	ERST
	JMP	RDDRC
	.ENDIF
;
;
; [comment is on truncated line]
;	   RETURN A=LO, X=HI. PER SET MINUS IF ERROR.
;	   INC IPTR PAST PARAM
;
GETNO	LDA	#4	MAX NO DIGITS
	STA	CTR
	LDA	#0
	STA	T1
	STA	T1+1	INIT TEMP TO BUILD NUMBER IN
GHS	LDX	IPTR
	LDA	LINE,X  GET CHAR
	INC	IPTR
	CMP	#CR	SEE OF TERMINATOR
	BEQ	GND
	CMP	#',
	BEQ	GND
	JSR	HEXCON	CONVERT ASCII TO NIBBLE
	BMI	ERRX	IF ERROR
	LDY	#3	SHIFT T1,T1+1 by 4
SHT1	CLC
	ROL	T1+1	[Save a byte: Use ASL and drop the CLC above]
	ROL	T1
	DEY
	BPL	SHT1
	ORA	T1+1	OR IN NEW NIBBLE
	STA	T1+1
	DEC	CTR	COUNT DIGIT
	BPL	GHS	LOOP UNLESS TOO MANY DIGITS
	LDA	#TMDL
	LDX	#TMDH
ERRX1	JSR	DSPLIN
	DEC	PER
	RTS
GND	LDA	T1+1
	LDX	T1
	RTS
ERRX	LDA	#IHPL	INVALID HEX PARAM
	LDX	#IHPH
	BNE	ERRX1
TMD	.BYTE	"TOO MANY DIGITS",CR
	HILO	TMD
TMDH	=	TMD/256
TMDL	=	-256*TMDH+TMD
IHP	.BYTE	"INVALID HEXADECIMAL PARAMETER",CR
	HILO	IHP
IHPH	=	IHP/256
IHPL	=	-256*IHPH+IHP

;
;
; HEXCON - CONVERT ASCII CHAR IN A TO HEX NIBBLE IN A. RETURN
;	    MINUS CONDITION, A=FF IF ERROR.
;
HEXCON	SEC
	SBC	#'0
	BMI	ERRX2
	CMP	#10
	BMI	OKX	0-9 CONVERTED SO EXIT
	SEC
	SBC	#'A-'0-10
	CMP	#10	CONVERTED VALUE MUST BE 10 OR MORE
	BMI	ERRX2	BETWEEN '9' AND 'A'
	CMP	#$10
	BMI	OKX	A-F CCONVERTED
ERRX2	LDA	#$FF
OKX	CMP	#0	SET STATUS BY VALUE IN A
	RTS

;
;	GETDN - GET A DEVICE NUMBER FROM LINE(IPTR)
;	 RETURN IT IN A
;
GETDN	BIT	PER	SEE IF PARAM ERROR ALREADY
	BMI	GDR	IF SO DONT BOTHER
	LDX	IPTR
GETD	LDA	LINE,X
	INX
	CMP	#'D	IF DN
	BEQ	GETD	GO GET DIGIT
	SEC
	SBC	#'0	CONVERT DIGIT
	BEQ	BDS	CANT BE ZERO
	BMI	BDS	IF NOT DIGIT
	CMP	#5	[hard-coded limit of 4 drives]
	BPL	BDS	TOO LARGE
	PHA
GD1	LDA	LINE,X
	INX
	CMP	#',
	BEQ	GDX	IF TERMINATOR
	CMP	#CR
	BNE	GD1	KEEP LOOKING
GDX	STX	IPTR	ADVANCE POINTER
	PLA
GDR	RTS
BDS	DEC	PER
	LDA	#NDSL	NEED DEVICE SPEC MSG
	LDX	#NDSH
	JSR	DSPLIN
	RTS
NDS	.BYTE	"NEED D1 THRU D4",CR
	HILO	NDS
NDSH	=	NDS/256
NDSL	=	-256*NDSH+NDS
;
; DRH - DEVICE REDIRECTION HANDLER
;
;	WHEN LOGICAL DEVICES ARE CREATED, THE HANDLER ADDRESS
;	POINTS HERE. THE DRH LOOKS UP THE PHYSICAL DEVICE SPEC
;	AT OPEN TIME AND CALLS THE APPROPRIATE HANDLER. THE IOCB
;	HANDLER ID IS THEN SET TO THAT HANDLER SO CIO CALLS AFTER
;	THE OPEN GO DIRECTLY TO THAT HANDLER.
;
DRH	=*
	HILO	DRH
DRHH	=	DRH/256
DRHL	=	-256*DRHH+DRH
;
;	HANDLER VECOTRS (ONLY OPEN IS USED)
;
	.WORD	EOPEN-1
LDNT	.BYTE	0,0,0,0,0

	*=*+5		UNUSED [zero fill in disassembly]
	RTS		INIT ROUTINE
;
PDST	*=*+80		TABLE OF PHYSICAL DEV:FILESPECS
	HILO	PDST
PDSTH	=	PDST/256
PDSTL	=	-256*PDSTH+PDST
EOPEN	LDY	#$00
	LDA	(ICBALZ),Y	GET LOGICAL DEVICE NAME
	JSR	FLDB	SEARCH LOG DEV NNAME TALBE
	BPL	FLD	IF FOUND IT OK
;INTERNAL ERROR IF WE GOT HERE
IERR	LDY	#$AC	NEW ERROR
HERRX	RTS
FLD	TXA		CREATE POINTER TO PHYSICAL DEVSPEC
	LDX	ICIDNO	GET IOCB #
	ASL	A
	ASL	A
	ASL	A
	ASL	A
	ADC	#PDSTL
	STA	ICBALZ
	STA	ICBAL,X	FOR FMS
	LDA	#0
	ADC	#PDSTH
	STA	ICBAHZ
	STA	ICBAH,X	FOR FMS
	JSR	DEVSRC	GO FIND PHYS DEVICE HID/DNO
	BCS	HERRX	IF ERRORS
	LDA	ICDNOZ
	STA	ICDNO,X	FOR FMS
	JSR	COMENT	GET PHYS DEV HDLR OPEN ENTRY
	BCS	HERRX
	JSR	GOHAND	GO DO REAL OPEN
	RTS		THATS ALL
	.END
; [disassembly has 146 zeros at the end]
