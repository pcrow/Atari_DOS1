RAMLO	= $001A
JMPTBL	= $001B
ICDNOZ	= $0021
ZBUFP	= $0043
ZDRVA	= $0045
ZSBA	= $0047
ERRNO	= $0049
MEMTOP	= $02E5
MEMLO	= $02E7
DUNIT	= $0301
DCBCMD	= $0302
DSTATS	= $0303
DBUFLO	= $0304
DBUFHI	= $0305
DCBSEC	= $030A
HATABS	= $031A
ICDNO	= $0341
ICCOM	= $0342
ICSTA	= $0343
ICBAL	= $0344
ICBAH	= $0345
ICAX1	= $034A
ICAX3	= $034C
ICAX4	= $034D
ICAX5	= $034E
FMSORG	= $0700
;DOS	= $1300  ; set dynamically
IRGEN	= $D20E
DKHND	= $E453
CIO	= $E456
SETVBV	= $E45C
SYSVBV	= $E45F
XITVBV	= $E462

LMASK	= 3	;LINK MASK

;
; DCBCMD VALUE EQUATES
;
DCBCRS	=	"R"	;Read sector     ($52)
DCBCWS	=	"P"	;Put sector      ($50)
DCBCST	=	"S"	;Status request  ($53)
DCBCFD	=	"!"	;FORMAT DISKETTE ($21)
;
; DCBSTA VALUE EQUATES
;
DCBSOK	=	$01	;STATUS NORMAL
DCBDNR	=	$81	;DEVICE NOT READY
DCBCNR	=	$82	;CONTROLLER NOT READY
DCBDER	=	$83	;DATA ERROR
DCBIVC	=	$84	;INVALID COMMAND
DCBWPR	=	$87	; WRITE PROTECT

	;.PAGE	"BOOT RECORD"
	*= FMSORG
;
; THE FOLLOWING BYTES ARE STORED
; ON DISK SECTOR 0 They COMPRISE
; THE BOOT LOAD RECORD
;
BFLG	.byte	$00	;BOOT FLAG UNUSED=0
BRCNT	.byte	$01	;NO CONSECTIVE BOOT RECRODS TO READ
BLDADR	.word	FMSORG	;BOOT LOAD ADDR
BINTADR	.word	DOS	;INIT ADDR
BCONT	JMP	XBCONT	;BOOT READ CONT PT
;
; THE FOLLOWING BYTES ARE SET BY
; THE CONSOLE PROCESSOR. THEY ARE
; ACTED UPON DURING FMS INIT ONLY.
; THEY ARE PART OF THE BOOT RECORD
; THUS DEFINING THE DEFAULT
;INITIALIZATION PARMS
;
SABYTE	.byte	3	;MAX # CONCURRENT OPEN FILES
DRVBYT	.byte	$0F	;DRIVE BITS
SAFBFW	.byte	$00	;STORAGE ALLOCATION DIR SW
SASA	.word	ENDPRG	;STORAGE ALLOCATION START ADDR
DFSFLG	.byte	$FF
	.byte	$00
DFLINK	.word	$0002	;DOS FILE START SECTOR NUMBER
XBCONT	LDA	DFSFLG
	BEQ	BFAIL
	LDA	#$07
	STA	ZBUFP+1
	LDA	#$03
	STA	ZBUFP
	JSR	INCBA
	LDA	DFLINK+1
	LDY	DFLINK
XBC1	CLC
	JSR	BSIO
	BMI	BFAIL
	LDY	#$7F
	LDA	(ZBUFP),Y
	BMI	BGOOD
	LDY	#$7D
	LDA	(ZBUFP),Y
	AND	#LMASK	;MASK TO LINK BITS
	PHA
	INY
	LDA	(ZBUFP),Y
	TAY
	JSR	INCBA
	PLA
	JMP	XBC1
BFAIL	LDA	#$C0	;SET FOR CARRY SET
	BNE	XBRTN	;ANY P,Y = $80
BGOOD	LDA	#$00	;SET FOR CARRY CLEAR
XBRTN	ASL
	TAY
	RTS
INCBA	CLC
	LDA	ZBUFP	;INC BUFFER PTR
	ADC	#$7D	;BY DATA LINK (125)
	STA	DBUFLO
	STA	ZBUFP
	LDA	ZBUFP+1
	ADC	#0
	STA	DBUFHI
	STA	ZBUFP+1
	RTS
BSIO	STA	DCBSEC+1
	STY	DCBSEC
	LDA	#DCBCRS
	BCC	DSIO1
	LDA	#"W"
DSIO1	STA	DCBCMD
L0772	JSR	DKHND
	LDX	CURFCB
	LDA	DSTATS
	RTS
DFMSDH	.word	DFMOPN-1
	.word	DFMCLS-1
	.word	DFMGET-1
	.word	DFMPUT-1
	.word	DFMSTA-1
	.word	DFMDDC-1
L0788	LDA	#$FF
	LDY	#$10
L078C	STA	DRVTBL,Y
	DEY
	BPL	L078C
	LDA	#$00
	STA	L1157
	LDA	DRVBYT
	LDX	#$07
L079C	ROL
	BCC	L07B4
	PHA
	LDA	L1157
	INC	L1157
	STA	DRVTBL,X
	TAY
	JSR	L0FB5
	LDY	#$05
	LDA	#$00
	STA	(ZDRVA),Y
	PLA
L07B4	DEX
	BPL	L079C
	LDA	#$00
	LDY	SABYTE
	DEY
L07BD	STA	SECTBL,Y
	DEY
	BPL	L07BD
	INY
L07C4	STA	FCBFNO,Y
	INY
	BNE	L07C4
	LDY	#$00
ADI1	LDA	HATABS,Y
	BEQ	ADI2
	CMP	#"D"
	BEQ	ADI2
	INY
	INY
	INY
	CPY	#$1E
	BNE	ADI1
	BRK
ADI2	LDA	#"D"
	STA	HATABS,Y
	LDA	#DFMSDH&255
	STA	HATABS+1,Y
	LDA	#DFMSDH/256
	STA	HATABS+2,Y
	LDA	L1157
	LDY	SABYTE
	INY
	JSR	L0FD4
	STA	MEMLO+1
	STY	MEMLO
	RTS
DFMOPN	JSR	SETUP
	JSR	L103B
	JSR	FNDCODE
	LDA	ICAX1,X
	STA	FCBOTC,X
	AND	#$02
	BEQ	OPN1
	JMP	LISTDIR
OPN1	JSR	SFDIR
	BCC	DHFOX2
	LDA	FCBOTC,X
	EOR	#$08
0	BNE	OPNER1
	LDA	DHOLES
	BMI	OPNER2
	STA	CDIRS
	JSR	RDDIR
	LDA	DHOLED
	STA	CDIRD
	LDA	DHFNUM
	STA	SFNUM
	JSR	RDVTOC
OPN1A	JSR	GETSECTOR	;GET A SECTOR
	LDY	CDIRD		;GET DIR DISPL
	STA	FILDIR+DFDSSN+1,Y ;PUT SECTOR INTO DIR REC
	LDA	FCBLSN,X
	STA	FILDIR+DFDSSN,Y
	LDA	#DFDINU		;SET DIR ENTRY IN USE
	STA	FILDIR+DFDFL1,Y
	LDA	#0
	STA	FILDIR+DFDCNT+1,Y ;SET COUNT = 0 [Bug fix (matches DOS 2 now)]
	STA	FILDIR+DFDCNT,Y
	TAX			;LDX	#0
OPN2	LDA	FNAME,X	;MOVE FILE NAME
	CMP	#"?"	;IF WILD CARD
	BNE	OPN2A
	LDA	#$20
OPN2A	STA	FILDIR+DFDPFN,Y
	INY
	INX
	CPX	#$0B
	BCC	OPN2
	LDX	CURFCB
	JSR	WRTDIR
	JSR	SETFCB
	JSR	WRTN6
	LDA	#$80
	STA	FCBFLG,X
	JSR	TSTDOS
	BNE	DHFOX3
	JMP	WRTDOS
OPNER1	JSR	ERFNF
OPNER2	JSR	ERDFULL
DHFOX2	JSR	SETFCB
	LDY	CDIRD
	LDA	FILDIR+DFDSSN,Y
	STA	FCBLSN,X
	LDA	FILDIR+DFDSSN+1,Y
	STA	FCBLSN+1,X
	JSR	RDNS1
	LDA	FCBOTC,X
	EOR	#$04
	BEQ	DHFOX3
	JSR	TSTLOCK
	LDA	FCBOTC,X
	AND	#$04
	BNE	DHFOX3
	JSR	RDVTOC
	LDA	#$80
	STA	FCBFLG,X
	LDA	FCBOTC,X
	AND	#$01
	BEQ	L08E1
	LDY	CDIRD
	LDA	FILDIR+DFDCNT+1,Y
	STA	FCBCNT+1,X
	LDA	FILDIR+DFDCNT,Y
	STA	FCBCNT,X
	BNE	L08D1
	DEC	FCBCNT+1,X
L08D1	DEC	FCBCNT
L08D4	JSR	RDNXTS
	BCC	L08D4
	LDA	FCBMLN,X
	STA	FCBDLN,X
	BCS	DHFOX3
L08E1	JSR	FRESECT
	JSR	RDNXTS
	BCC	L08E1
	JMP	OPN1A
DHFOX3	JMP	GREAT
SETFCB	LDA	#$00
	STA	FCBFLG,X
	LDA	SFNUM
	ASL
	ASL
	STA	FCBFNO,X
	LDA	#$00
	STA	FCBDLN,X
	STA	FCBSSN,X
	STA	FCBSSN+1,X
	STA	FCBCNT,X
	STA	FCBCNT+1,X
	RTS
DFMPUT	STA	SVDBYT
	LDA	ICDNO,X
	STA	ICDNOZ
	JSR	SETUP
	LDY	FCBDLN,X
	CPY	#$7D
	BCC	PUT1
	JSR	WRTNXS
	LDA	#$00
	STA	FCBDLN,X
	TAY
PUT1	INC	FCBDLN,X
	LDA	SVDBYT
	STA	(ZSBA),Y
	LDA	#$40
	ORA	FCBFLG,X
	STA	FCBFLG,X
	JMP	GREAT
DFMGET	JSR	SETUP
	LDA	FCBOTC,X
	AND	#$02
	BEQ	GET1
	JMP	GDCHAR
GET1	LDA	FCBDLN,X
	CMP	FCBMLN,X
	BCC	GET2
	JSR	RDNXTS
	BCC	GET1
	JMP	ERREOF
GET2	TAY
	LDA	(ZSBA),Y
	STA	SVDBYT
	INY
	TYA
	STA	FCBDLN,X
	LDY	FCBLSN,X
	BNE	GET3
	LDY	FCBLSN+1,X
	BNE	GET3
	CMP	FCBMLN,X
	BCC	GET3
	LDA	#$03
	JMP	RETURN
GET3	JMP	GREAT
DFMSTA	JSR	SETUP
	JSR	FNDCODE
	JSR	SFDIR
	BCS	SFNF
	JSR	TSTLOCK
	JMP	GREAT
SFNF	JMP	ERFNF
DFMCLS	JSR	SETUP
	LDA	FCBOTC,X
	AND	#$09
	BEQ	CLDONE
	ROL	FCBFLG,X
	BCC	CLUPDT
	LDA	FCBDLN,X
	ORA	#$80
	JSR	WRTLS1
	JSR	RRDIR
CLDONE	LDA	#$00
	STA	FCBOTC,X
	JMP	FGREAT
FNSHFT	LDA	#$00
FNSHF1	LDY	#$03
FNSHF2	ASL	FCBFNO,X
	ROL
	DEY
	BNE	FNSHF2
	RTS
CLUPDT	JSR	WRTNXS
	JMP	CLDONE
RRDIR	JSR	FNSHFT
	STA	CDIRS
	JSR	FNSHFT
	JSR	FNSHF1
	ASL
	STA	CDIRD
	JSR	RDDIR
	LDY	CDIRD
	LDA	FCBCNT+1,X
	STA	FILDIR+DFDCNT+1,Y
	LDA	FCBCNT,X
	STA	FILDIR+DFDCNT,Y
	JSR	WRTDIR
	JMP	WRTVTOC
DFMDDC	JSR	SETUP
	LDA	ICCOM,X
	CMP	#$FE
	BEQ	XFV
	CMP	#$27
	BCS	DVDCER
	SEC
	SBC	#$20
	BCC	DVDCER
	ASL
	TAY
	LDA	DVDCVT,Y
	PHA
	LDA	DVDCVT+1,Y
	PHA
	RTS
DVDCVT	.byte (XRENAME-1)/256,-256*((XRENAME-1)/256)+(XRENAME-1)	;.dbyte	XRENAME-1
	.byte (XDELETE-1)/256,-256*((XDELETE-1)/256)+(XDELETE-1)	;.dbyte	XDELETE-1
	.byte (DVDCER-1)/256,-256*((DVDCER-1)/256)+(DVDCER-1)	;.dbyte	DVDCER-1
	.byte (XLOCK-1)/256,-256*((XLOCK-1)/256)+(XLOCK-1)	;.dbyte	XLOCK-1
	.byte (XUNLOCK-1)/256,-256*((XUNLOCK-1)/256)+(XUNLOCK-1)	;.dbyte	XUNLOCK-1
	.byte (XPOINT-1)/256,-256*((XPOINT-1)/256)+(XPOINT-1)	;.dbyte	XPOINT-1
	.byte (XNOTE-1)/256,-256*((XNOTE-1)/256)+(XNOTE-1)	;.dbyte	XNOTE-1
DVDCER	JMP	ERDVDC
XFV	JMP	XFORMAT
XRENAME	JSR	FNDCODE
	STY	TEMP2
	JSR	SFDIR
	BCC	XRN1
	JMP	ERFNF
XRN1	JSR	TSTLOCK
	JSR	TSTDOS
	BNE	XRN1A
	JSR	DELDOS
XRN1A	LDY	TEMP2
	JSR	FNDCNX
	JSR	TSTDOS
	BNE	XRN1B
	LDY	CDIRD
	LDA	FILDIR+DFDSSN+1,Y
	PHA
	LDA	FILDIR+DFDSSN,Y
	TAY
	PLA
	JSR	SETDSO
XRN1B	LDX	#$00
	LDY	CDIRD
XRN2	LDA	FNAME,X	;MOVE FILE NAME
	CMP	#"?"	;FROM FNAME TO DIR ENT
	BEQ	XRN3	;BUT DON'T CHANGE WILD CARD
	STA	FILDIR+DFDPFN,Y
XRN3	INY
	INX
	CPX	#$0B
	BCC	XRN2
	LDX	CURFCB
	JSR	WRTDIR
	JSR	FNDCODE
	JSR	CFSDIR
	BCC	XRN1
	JMP	FGREAT
XDELETE	JSR	FNDCODE
	JSR	SFDIR
	BCC	XDEL0
	JMP	ERFNF
XDEL0	JSR	RDVTOC
XDEL1	LDY	CDIRD
	JSR	TSTLOCK
	LDA	#DFDEDE
	STA	FILDIR,Y
	LDA	FILDIR+DFDSSN,Y
	STA	FCBLSN,X
	LDA	FILDIR+DFDSSN+1,Y
	STA	FCBLSN+1,X
	JSR	SETFCB
	JSR	RDNS1
	JMP	XDEL2A
XDEL2	JSR	RDNXTS
	BCS	XDEL4
XDEL2A	JSR	FRESECT
	JMP	XDEL2
XDEL4	JSR	WRTDIR
	JSR	CFSDIR
	BCC	XDEL1
	JSR	WRTVTOC
	JSR	TSTDOS
	BNE	XDELY
	JSR	DELDOS
XDELY	JMP	FGREAT
XLOCK	LDA	#$20
	STA	TEMP4
	BNE	XLCOM
XUNLOCK	LDA	#$00
	STA	TEMP4
XLCOM	JSR	FNDCODE
	JSR	SFDIR
	BCC	XLC1
	JMP	ERFNF
XLC1	LDY	CDIRD
	LDA	FILDIR,Y
	AND	#$DF
	ORA	TEMP4
	STA	FILDIR,Y
	JSR	WRTDIR
	JSR	CFSDIR
	BCC	XLC1
	JMP	FGREAT
TSTLOCK	LDY	CDIRD
	LDA	FILDIR,Y
	AND	#$20
	BNE	TLF
	RTS
TLF	JMP	ERFLOCK
XPOINT	LDA	FCBFLG,X
	BMI	PERR1
	LDA	ICAX4,X
	CMP	FCBCSN+1,X
	BNE	XP1
	LDA	ICAX3,X
	CMP	FCBCSN,X
	BEQ	XP2
XP1	JSR	WRTNXS
	LDA	ICAX4,X
	STA	FCBLSN+1,X
	LDA	ICAX3,X
	STA	FCBLSN,X
	JSR	RDNS1
XP2	LDA	ICAX5,X
	CMP	FCBMLN,X
	BCC	XP3
	BEQ	XP3
	JMP	ERRPDL
XP3	STA	FCBDLN,X
	JMP	GREAT
PERR1	JMP	ERRPOT
XNOTE	LDA	FCBDLN,X
	STA	ICAX5,X
	LDA	FCBCSN,X
	STA	ICAX3,X
	LDA	FCBCSN+1,X
	STA	ICAX4,X
	JMP	GREAT
XFORMAT	LDA	ZDRVA+1
	STA	DBUFHI
	LDA	ZDRVA
	STA	DBUFLO
	LDA	#DCBCFD
	JSR	DSIO1
	LDA	#$00
	TAY
XF1	STA	(ZDRVA),Y
	INY
	BPL	XF1
	LDY	#$00
	LDA	#$01
	STA	(ZDRVA),Y
	INY
	LDA	#$C5
	STA	(ZDRVA),Y
	INY
	INY
	STA	(ZDRVA),Y
	LDA	#$02
	DEY
	STA	(ZDRVA),Y
	INY
	INY
	STA	(ZDRVA),Y
	LDY	#$0A
	LDA	#$FF
XF2	STA	(ZDRVA),Y
	INY
	CPY	#$64
	BNE	XF2
	LDA	#$3F
	LDY	#$0A
	STA	(ZDRVA),Y
	LDY	#$37
	LDA	#$00
	STA	(ZDRVA),Y
	INY
	LDA	#$7F
	STA	(ZDRVA),Y
	JSR	WRTVTOC
	LDA	#$00
	TAY
XF3	STA	FILDIR,Y
	INY
	BPL	XF3
	LDA	#$07
	STA	CDIRS
XF4	JSR	WRTDIR
	DEC	CDIRS
	BPL	XF4
	JSR	DELDOS
	JMP	FGREAT
LISTDIR	LDA	#$00
	STA	TEMP4
	JSR	SFDIR
	BCC	LDENT1
	BCS	LDCNT
GDCHAR	BIT	TEMP4
	BMI	LDDONE
	LDY	TEMP4
	LDA	(ZSBA),Y
	STA	SVDBYT
	INC	TEMP4
	CMP	#$9B
	BNE	GDCRTN
	CPY	#$04
	BCS	LDENT
	LDA	#$80
	STA	TEMP4
GDCRTN	JMP	GREAT
LDENT	LDA	#$00
	STA	TEMP4
	JSR	CFSDIR
	BCS	LDCNT
LDENT1	JSR	FDENT
	JMP	GREAT
LDCNT	JSR	RDVTOC
	LDY	#$04
	LDA	(ZDRVA),Y
	PHA
	DEY
	LDA	(ZDRVA),Y
	TAY
	PLA
	JSR	CVDX
	LDY	#$03
	JSR	CVDY
	LDA	#$00
	STA	TEMP4
	JMP	FGREAT
LDDONE	JMP	ERREOF
FDENT	LDY	#$00
	LDA	#$20
	STA	(ZSBA),Y
	LDX	CDIRD
	LDA	FILDIR,X
	AND	#$20
	BEQ	LD1
	LDA	#"*"	;CHANGE TO AST
	STA	(ZSBA),Y
LD1	INY
	LDA	#$20	;FOLLOWED BY A BLANK
	STA	(ZSBA),Y
	INY
LD2	LDA	FILDIR+DFDPFN,X
	STA	(ZSBA),Y
	INX
	INY
	CPY	#$0D
	BCC	LD2
	LDA	#$20
	STA	(ZSBA),Y
	INY
	STY	TEMP4
	LDX	CDIRD
	LDY	FILDIR+DFDCNT,X
	LDA	FILDIR+DFDCNT+1,X ;BUG FIX!!! They left off the ",X" which broke directory listing sector counts for large files
CVDX	LDX	#$64
	JSR	CVDIGIT
	LDX	#$0A
	JSR	CVDIGIT
	TYA
	JSR	STDIGIT
	LDY	#$11
CVDY	LDA	#$9B
	STA	(ZSBA),Y
	LDY	#$00
	STY	TEMP4
	RTS
CVDIGIT	STX	TEMP3
	LDX	#$FF
CVD1	STA	TEMP2
	STY	TEMP1
	INX
	SEC
	LDA	TEMP1
	SBC	TEMP3
	TAY
	LDA	TEMP2
	SBC	#$00
	BCS	CVD1
	TXA
STDIGIT	ORA	#$30
	LDY	TEMP4
	STA	(ZSBA),Y
	INC	TEMP4
	LDA	TEMP2
	LDY	TEMP1
	RTS
FNDCODE	LDA	ICBAL,X
	STA	ZBUFP
	LDA	ICBAH,X
	STA	ZBUFP+1
	LDY	#$02
FD0A	LDA	(ZBUFP),Y
	DEY
	BMI	FNDERR
	CMP	#":"
	BNE	FD0A
	INY
FNDCNX	LDX	#$0B
	LDA	#$20
FD0	STA	FNAME,X
	DEX
	BPL	FD0
	LDX	#$00
	STX	TEMP1
FD1	INY
	LDA	(ZBUFP),Y
	CMP	#"*"
	BNE	FD3
FD2	LDA	#"?"
	JSR	FDSCHAR
	BCC	FD2
	BPL	FD1
	BMI	FDEND
FD3	CMP	#"."
	BNE	FD4
	BIT	TEMP1
	BMI	FDEND
	LDX	#$08
	ROR	TEMP1
	BCC	FD1
FD4	CMP	#"?"
	BEQ	FD6
	CMP	#"A"	;IS CHAR ALPHA
	BCC	FD5	;BR NOT ALPHA
	CMP	#$5B	;TEXT HI ALPHA
	BCC	FD6	;BR IF NOT ALPHA
FD5	CPX	#$00
	BEQ	FNDERR
	CMP	#$30
	BCC	FDEND
	CMP	#$3A
	BCS	FDEND
FD6	JSR	FDSCHAR
	JMP	FD1
FDEND	LDX	CURFCB
	RTS
FNDERR	JMP	ERRFN
FDSCHAR	CPX	#$08
	BCC	FDSC2
	BEQ	FDSC1
	CPX	#$0C
	BCC	FDSC2
	RTS
FDSC1	BIT	TEMP1
	BMI	FDSC2
	RTS
FDSC2	STA	FNAME,X
	INX
	CLC
	RTS
SFDIR	LDA	#$FF
	STA	DHOLES
	STA	CDIRS
	STA	SFNUM
	LDA	#$70
	STA	CDIRD
CFSDIR	INC	SFNUM
	CLC
	LDA	CDIRD
	ADC	#$10
	BPL	SFD2
	INC	CDIRS
	LDA	#$08
	CMP	CDIRS
	BCC	SFD1
	BEQ	SDRTN
SFD1	JSR	RDDIR
	LDA	#$00
SFD2	STA	CDIRD
	TAY
	LDA	FILDIR,Y
	BEQ	SFDSH
	BMI	SFDSH
	LDX	#0	;TEST MATCH ON 12 CHARS
SFD3	LDA	FNAME,X	;FILE NAME CHAR
	CMP	#"?"	;IS FNC WILD CARD
	BEQ	SFD4	;THEN IT MATCHES
	CMP	FILDIR+DFDPFN,Y	;ELSE IT MUST MATCH FO
	BNE	CFSDIR	;IF NOT MATCH THEN TRY NEXT
SFD4	INX
	INY
	CPX	#$0B
	BNE	SFD3
	CLC
	BCC	SDRTN
SFDSH	LDA	DHOLES
	BPL	SFDSH1
	LDA	CDIRS
	STA	DHOLES
	LDA	CDIRD
	STA	DHOLED
	LDA	SFNUM
	STA	DHFNUM
SFDSH1	LDA	FILDIR,Y
	BMI	CFSDIR
	SEC
SDRTN	LDX	CURFCB
	RTS
WRTNXS	LDA	FCBFLG,X
	BMI	WRTN1
	ASL
	BPL	WRU1
	ASL
	STA	FCBFLG,X
	JSR	WRCSIO
	BMI	WRNERR
WRU1	JMP	RDNXTS
WRTN1	JSR	GETSECTOR
	LDA	FCBCNT,X
	AND	#$7F
WRTLS1	LDY	#$7F
	STA	(ZSBA),Y
	LDA	#$02
	STA	TEMP3
WRTN2	LDA	FCBLSN+1,X	;MOVE LINK SECTOR
	ORA	FCBFNO,X	;PLUS FILE NUM
	LDY	#$7D		;TO BYTES 126,127
	STA	(ZSBA),Y	;OF SECTOR BUFF
	INY
	LDA	FCBLSN,X
	STA	(ZSBA),Y
	JSR	WRCSIO		;WRITE SECTOR
	BPL	WRTN5		;BR NOT ERROR
	DEC	TEMP3
	BPL	L0DDD
WRNERR	LDA	DSTATS
	STA	TEMP4
	JSR	RRDIR
	LDA	#$00
	STA	FCBOTC,X
	LDA	TEMP4
	JMP	RETURN
L0DDD	JSR	MVLSN
	JSR	GETSECTOR
	JMP	WRTN2
WRTN5	LDA	TEMP3
	CMP	#$02
	BEQ	L0E05
	CLC
	JSR	L0E28
	LDY	#$7D
	LDA	FCBCSN+1,X
	ORA	FCBFNO,X
	STA	(ZSBA),Y
	INY
	LDA	FCBCSN,X
	STA	(ZSBA),Y
	SEC
	JSR	L0E28
L0E05	LDA	FCBCSN,X
	STA	FCBSSN,X
	LDA	FCBCSN+1,X
	STA	FCBSSN+1,X
	INC	FCBCNT,X	;INC SECTOR CNT
	BNE	WRTN6
	INC	FCBCNT+1,X
WRTN6	JSR	MVLSN		;LINK TO CUR
	LDA	#0
	STA	FCBLSN,X	;LINK= 0
	STA	FCBLSN+1,X
	STA	FCBDLN,X	;DLN = 0
	RTS
L0E28	LDY	FCBSSN,X
	LDA	FCBSSN+1,X
	BNE	L0E35
	LDY	FCBSSN,X
	BEQ	WRNERR
L0E35	JSR	DSIO
	BMI	WRNERR
	RTS
WRCSIO	SEC
RWCSIO	LDA	FCBCSN+1,X
	LDY	FCBCSN,X
	JMP	DSIO
MVLSN	LDA	FCBLSN,X
	STA	FCBCSN,X
	LDA	FCBLSN+1,X
	STA	FCBCSN+1,X
	RTS
RDNXTS	LDY	#$7F
	LDA	(ZSBA),Y
	BPL	RDNS1
	SEC
	RTS
RDNS1	JSR	MVLSN
	CLC
	JSR	RWCSIO
	BMI	RDIOER
	LDY	#$7D
	LDA	(ZSBA),Y
	AND	#$FC
	CMP	FCBFNO,X
	BNE	RDFNMM
	LDA	(ZSBA),Y
	AND	#$03
	STA	FCBLSN+1,X
	INY
	LDA	(ZSBA),Y
	STA	FCBLSN,X
	INY
	LDA	(ZSBA),Y
	BMI	RDNS2
	LDA	#$7D
RDNS2	AND	#$7F
	STA	FCBMLN,X
	LDA	#$00
	STA	FCBDLN,X
	CLC
	RTS
RDIOER	JSR	ERRIO
RDFNMM	LDA	ICCOM,X
	CMP	#$21	;WAS THIS DELETE
	BEQ	RDDELE	;BR IF DELETE
	JSR	ERFNMM	;BR NOT DELETE
RDDELE	SEC
	RTS
RDDIR	CLC
	BCC	DIRIO
WRTDIR	SEC
DIRIO	PHP
	LDA	#FILDIR/256
	STA	DBUFHI
	LDA	#FILDIR&255
	STA	DBUFLO
	CLC
	LDA	CDIRS
	ADC	#$69
	TAY
	LDA	#$01
	ADC	#$00
	JMP	DSYSIO
RDVTOC	LDY	#$05
	LDA	(ZDRVA),Y
	BEQ	RDVGO
	JSR	WRTVTOC
RDVGO	CLC
	BCC	VTIO
WRTVTOC	LDY	#$05
	LDA	#$00
	STA	(ZDRVA),Y
	SEC
VTIO	PHP
	LDA	ZDRVA+1
	STA	DBUFHI
	LDA	ZDRVA
	STA	DBUFLO
	LDY	#$68
	LDA	#$01
DSYSIO	PLP
BSIOR	JSR	BSIO
	BMI	DSIOER
	RTS
DSIOER	CMP	#$83
	BEQ	DEAD
	JMP	ERRIO
DEAD	JMP	ERRSYS
FRESECT	LDA	#$00
	LDY	#$03
FS1	LSR	FCBCSN+1,X
	ROR	FCBCSN,X
	ROR
	DEY
	BNE	FS1
	LDY	#$05
FS2	ROR
	DEY
	BNE	FS2
	TAY
	LDA	#$00
	SEC
FS3	ROR
	DEY
	BPL	FS3
	PHA
	LDA	FCBCSN,X
	ADC	#$0A
	TAY
	PLA
	ORA	(ZDRVA),Y
	STA	(ZDRVA),Y
	LDY	#$03
	LDA	(ZDRVA),Y
	CLC
	ADC	#$01
	STA	(ZDRVA),Y
	INY
	LDA	(ZDRVA),Y
	ADC	#$00
	STA	(ZDRVA),Y
	INY
	LDA	#$FF
	STA	(ZDRVA),Y
	RTS
GETSECTOR	LDY	#$09
GS1	INY
	CPY	#$64
	BCS	GSERR
	LDA	(ZDRVA),Y
	BEQ	GS1
	STY	TEMP1
	PHA
	SEC
	LDY	#$03
	LDA	(ZDRVA),Y
	SBC	#$01
	STA	(ZDRVA),Y
	INY
	LDA	(ZDRVA),Y
	SBC	#$00
	STA	(ZDRVA),Y
	INY
	LDA	#$FF
	STA	(ZDRVA),Y
	PLA
	LDY	#$FF
GS2	INY
	ASL
	BCC	GS2
	STY	TEMP2
GS3	LSR
	DEY
	BPL	GS3
	LDY	TEMP1
	STA	(ZDRVA),Y
	SEC
	LDA	TEMP1
	SBC	#$0A
	LDY	#$00
	STY	TEMP1
GS4	ASL
	ROL	TEMP1
	INY
	CPY	#$03
	BCC	GS4
	CLC
	ADC	TEMP2
	STA	FCBLSN,X
	LDA	TEMP1
	ADC	#$00
	STA	FCBLSN+1,X
	RTS
GSERR	JMP	ERRNSA
SETUP	LDA	#$9F
	STA	ERRNO
	STX	CURFCB
	TSX
	INX
	INX
	STX	ENTSTK
	LDX	CURFCB		;GET CURRENT FCB
	;LDA	ICDNO,X		; this is obviously useless
	LDA	ICDNOZ		;MOVE DRIVE NO
	STA	DUNIT
	JSR	L0FA7
	JMP	L103B
L0FA7	LDY	DUNIT
	CPY	#$08
	BCC	L0FB0
	BNE	DERR1
L0FB0	DEY
	LDA	DRVTBL,Y
	TAY
L0FB5	BMI	DERR1
	LDA	#$00
	JSR	L0FD4
	STA	ZDRVA+1
	STY	ZDRVA
	RTS
DERR1	JMP	ERRDNO
L0FC4	LDY	FCBBUF,X
	DEY
	TYA
	LDY	L1157
	JSR	L0FD4
	STA	ZSBA+1
	STY	ZSBA
	RTS
L0FD4	STY	TEMP1
	LDY	#$00
	STY	TEMP2
	CLC
	LDY	SAFBFW
	BPL	L0FE3
	SEC
L0FE3	ADC	TEMP1
	LSR
	ROR	TEMP2
	STA	TEMP1
	BIT	SAFBFW
	BMI	L1001
	CLC
	LDA	SASA
	ADC	TEMP2
	TAY
	LDA	SASA+1
	ADC	TEMP1
	RTS
L1001	SEC
	LDA	SASA
	SBC	TEMP2
	TAY
	LDA	SASA+1
	SBC	TEMP1
	RTS
DSIO	STA	DCBSEC+1
	STY	DCBSEC
	LDA	#DCBCRS
	BCC	L101C
	LDA	#"W"
L101C	STA	DCBCMD
	LDA	ZSBA
	STA	DBUFLO
	LDA	ZSBA+1
	STA	DBUFHI
	LDY	#$02
L102B	TYA
	PHA
	JSR	L0772
	PLA
	TAY
	LDA	DSTATS
	BPL	L103A
	DEY
	BPL	L102B
L103A	RTS
L103B	LDA	FCBBUF,X
	BNE	SSBA
	LDY	#$07
GSB1	LDA	SECTBL,Y
	BEQ	GSB4
	DEY
	BPL	GSB1
	JMP	ERRNSB
GSB4	INY
	TYA
	STA	FCBBUF,X
	LDA	#$80
	DEY
	STA	SECTBL,Y
SSBA	JMP	L0FC4
FRESBUF	LDY	FCBBUF,X
	BEQ	FSBR
	DEY
	LDA	#$00
	STA	SECTBL,Y
	STA	FCBBUF,X
FSBR	RTS
WRTDOS	LDY	FCBCSN,X
	LDA	FCBCSN+1,X
	JSR	SETDSO
	JSR	WD0
	JMP	GREAT
DELDOS	LDA	#$00
DD1_	STA	DFSFLG
	LDA	#FMSORG/256
	STA	DBUFHI
	LDA	#FMSORG&255
	STA	DBUFLO
	LDA	#$00
	TAY
	INY
	SEC
	JMP	BSIOR
SETDSO	STY	DFLINK
	STA	DFLINK+1
	LDA	#$FF
	BNE	DD1_
WD0	LDA	#$07
	STA	ZBUFP+1
	LDA	#$80
	STA	ZBUFP
WD1	LDY	#$00
WD2	LDA	(ZBUFP),Y
	STA	(ZSBA),Y
	INY
	CPY	#$7D
	BCC	WD2
	TYA
	STA	FCBDLN,X
	JSR	INCBA
	CMP	#ENDCODE/256
	BCC	WD3
	BNE	WD4
	LDA	ZBUFP
	CMP	#ENDCODE&255
	BCC	WD3
	BNE	WD4
WD3	JSR	WRTNXS
	JMP	WD1
;WD4	RTS
TSTDOS	LDY	#11	;LOOK AT 12 CHARS
TDF1	LDA	FNAME-1,Y	;TEST DECODE FILENAME CHAR
	CMP	DFN-1,Y	;WITH DOS FILENAME CHAR
	BNE	DFN-1	;BR NOT MATCH
	DEY
	BNE	TDF1	;BR IF MORE, ELSE RTN EQ
WD4	RTS
DFN	.byte	"DOS     SYS "	;; [extraneous space at the end?]
ERRPOT	INC	ERRNO
ERFNF	INC	ERRNO
ERDFULL	INC	ERRNO
ERDVDC	INC	ERRNO
ERFLOCK	INC	ERRNO
ERRPDL	INC	ERRNO
ERRFN	INC	ERRNO
ERFNMM	INC	ERRNO
ERRSYS	INC	ERRNO
ERRNSA	INC	ERRNO
ERRNSB	INC	ERRNO
ERRDNO	INC	ERRNO
	LDA	ERRNO
RETURN	LDX	CURFCB
	STA	ICSTA,X
	LDX	ENTSTK
	TXS
	LDX	CURFCB
	TAY
	LDA	SVDBYT
INITX	RTS
ERRIO	LDA	DSTATS
	BMI	RETURN
FGREAT	JSR	FRESBUF
GREAT	LDA	#$01
	BNE	RETURN
ERREOF	LDA	#$88
	BMI	RETURN
; https://archive.org/details/ataridiskutilities/page/n1/mode/2up
; [ entries in brackets are comments added in transcribing from the scan ]
; [lots of transcribing errors are likely; the original scan is low resolution]
; [note: DOS is 0700-12FF and is not included in the listings]
; [note: Scans of the pages often appear to cut off the last line of text]

; [cover page]
;
; [stamp:]
; ATARI PRELIMINARY CONFIDENTIAL
;
; [handwritten:]
; 1 of 10
;
; DISK UTILITIES
;
; [cursive handwriting, not fully legible:] Sent To Gary

;SYSRES	=	0	;***USER RAM RESIDENT VERSION ***
SYSRES	=	1	;***SYSTEM RAM RESIDENT VERSION ***
;CIO	=	$E456
;DKHND	=	$E453
;SETVBV	=	$E45C
;SYSVBV	=	$E45F
;XITVBV	=	$E462
;MEMTOP	=	$2E5
;IRGEN	=	$D20E
BRKKEY	=	$11
POKMSK	=	$10
DOSVEC	=	$A
WARMST	=	8
CARTST	=	$BFFA
;MEMLO	=	$2E7
SHFLOK	=	$2BE
RUNAD	=	$2E0
ICHIDZ	=	$20
;ICDNOZ	=	$21
ICBALZ	=	$24
ICBAHZ	=	$25
ICIDNO	=	$2E
MAXDEV	=	$21-3	; one less HATAB entry on XL OS
;HATABS	=	$31A
;CIO SUBROUTINES (moved on XL so don't use them)
;COMENT	=	$E63D
;GOHAND	=	$E689
;DEVSRC	=	$E69E
	;.TITLE	"COLLEEN DISK UTILITIES"
;
;
;
;***********************************************************************
;		FILENAME =DK1:DUPV.SRC
;***********************************************************************
;
;	DISK UTILITY ROUTINE FOR COLLEEN O.S.
;
;HILO	.MACRO	&1
;&1H	=	&1/256
;&1L	=	-256*&1H+&1
	;.ENDM
;
;
;	ZERO PAGE VARIABLES
;
;	*=$18
JMPTBL_	= $18	; JMPTBL for DOS and DUP are separate
;RAMLO	*=*+2
;
;
;
;
;
;
USRDOS	=	$1700
FMS	=	$700
FMINIT	=	FMS+$88
; [end of page cut off slightly]
; [equate used below is probably here]
;DOS	=	$1300
;


	;.IF	SYSRES
	;*=DOS
DOS = *
	LDA	#DOSOSL
	STA	DOSVEC
	LDA	#DOSOSH
	STA	DOSVEC+1
	JSR	FMINIT
	LDA	WARMST	;ON COLDSTART, LOAD AUTO.SYS
	BNE	INITX
	LDA	#AFL
	STA	ICBAL+$10
	LDA	#AFH
	STA	ICBAH+$10
	JMP	LOAD	;LOAD VECTOR, ALSO INIT LOAD AND EXIT.
;INITX	RTS	; use RTS above instead
AF	.BYTE	"D1:AUTO.SYS",CR
	;HILO	AF
;[equates are shown in listing but generated by above macro:]
AFH	=	AF/256
AFL	=	-256*AFH+AF
	;.ENDIF
;	;.IF	SYSRES-1
;	*=USRDOS
;LOADV	=	$1319
;	;.ENDIF
;
CR	=	$9B
CUP	=	$1C
CDN	=	$1D
CLF	=	$1E
CRT	=	$1F
DLL	=	$9C
CLSCR	=	$7D
;
;
OPEN	=	$03
CLOSE	=	$0C
PUTCHR	=	$0A
GETCHR	=	$06
GETRCD	=	$04
PUTRCD	=	$08
RENAME	=	$20
DELETE	=	$21
FORMAT	=	$FE
LOCK	=	$23
UNLOCK	=	$24
;
TEXT	=	1
;
;
DCB	=	$300
;DUNIT	=	DCB+1
DCOMND	=	DCB+2
;DSTATS	=	DCB+3
;DBUFLO	=	DCB+4
;DBUFHI	=	DCB+5
DSLO	=	DCB+$A

DSHI	=	DCB+$B
;
IOCB	=	$340
ICHID	=	IOCB+0
;ICDNO	=	IOCB+1
;ICCOM	=	IOCB+2
;ICSTA	=	IOCB+3
;ICBAL	=	IOCB+4
;ICBAH	=	IOCB+5
ICBLL	=	IOCB+8
ICBLH	=	IOCB+9
;ICAX1	=	IOCB+10
ICAX2	=	IOCB+11
;
;

SAVH	.BYTE	$84,$09
	;HILO	SAVH
SAVHH	=	SAVH/256
SAVHL	=	-256*SAVHH+SAVH
EDN	.BYTE	"E:",CR
EDH	=	EDN/256
EDL	=	-256*EDH+EDN
KDN	.BYTE	"K:",CR
	;HILO	KDN
KDNH	=	KDN/256
KDNL	=	-256*KDNH+KDN
;
;
DMENU	.BYTE	CLSCR
	.BYTE	"DISK OPERATING SYSTEM   9/24/79",CR
	.BYTE	"COPYRIGHT 1979 ATARI",CR,CR
	.BYTE	"A. DISK DIRECTORY I. FORMAT DISK",CR
	.BYTE	"B. RUN CARTRIDGE  J. DUPLICATE DISK",CR
	.BYTE	"C. COPY FILE      K. BINARY SAVE",CR
	.BYTE	"D. DELETE FILE(S) L. BINARY LOAD",CR
	.BYTE	"E. RENAME FILE    M. RUN AT ADDRESS",CR
	.BYTE	"F. LOCK FILE      N. DEFINE DEVICE",CR
	.BYTE	"G. UNLOCK FILE    O. DUPLICATE FILE",CR
	.BYTE	"H. WRITE DOS FILE",CR

	.BYTE	CDN,CDN,CDN,CDN,CDN
DMEND	=*
DULEN	=	DMEND-DMENU
	;HILO	DULEN
DULENH	=	DULEN/256
DULENL	=	-256*DULENH+DULEN
	;HILO	DMENU
DMENUH	=	DMENU/256
DMENUL	=	-256*DMENUH+DMENU
;
DUJPT	.WORD	DIRLST,STCAR,CPYFIL,DELFIL,RENFIL,LKFIL,ULFIL
	.WORD	WBOOT,FMTDSK,DUPDSK,SAVFIL,LDFIL,BRUN,DEFDEV
	.WORD	DUPFIL
	;HILO	DUJPT
DUJPTH	=	DUJPT/256
DUJPTL	=	-256*DUJPTH+DUJPT
DUNUM	=	15	;NUMBER OF FUNCTIONS
;
;
;***********************************************************************
;	DISK UTILITY ROUTINE STARTS HERE
;***********************************************************************
;
;
;
;
;
;
;	DISK OPERATING SYS MONITOR
;
DOSOS	LDA	#$FF
	;HILO	DOSOS
DOSOSH	=	DOSOS/256
DOSOSL	=	-256*DOSOSH+DOSOS
	STA	BRKKEY
	STA	WARMST
	LDA	POKMSK	;ENABLE BREAK INTERRUPTS
	ORA	#$80
	STA	POKMSK
	STA	IRGEN
	JSR	INITIO	;CLOSE FILES
	LDA	#OPEN
	STA	ICCOM+$30	;K: IOCB [IOCB3+2]
	LDX	#$30	;K: IOCB
	LDA	#$04
	STA	ICAX1,X	;OPEN READ
	LDA	#KDNH
	STA	ICBAH,X	;[IOCB0+5,X]
	LDA	#KDNL
	STA	ICBAL,X	;[IOCB0+4,X]
	JSR	CIO	;[line missing from listing]

;
;	DISK UTILITY MONITOR
;
DSKUTL
DUI	LDA	#DUNUM
	STA	MENUSZ	;SET MENU SIZE
	LDA	#DUJPTL
	STA	JMPTBL_
	LDA	#DUJPTH
	STA	JMPTBL_+1	;SET UP JUMP TABLE ADDRESS
	LDA	#DMENUL
	STA	MNA	;SET UP FOR MENU COPY
	LDA	#DMENUH
	STA	MNA+1
	LDA	#DULENL
	STA	MNL
	LDA	#DULENH
	STA	MNL+1
; FAL LTHRU TO MENU SELECT
;
;
;
;	MENU SELECT MONITOR -- VECTORS TO ROUTINE SELECTED FROM MENU.
;
SHMEN	LDA	#0	;CLEAR PAUSE AND SHOW MENU FLAG
	STA	RDM
	LDA	MNA
	STA	ICBAL
	LDA	MNA+1
	STA	ICBAH
	LDA	MNL
	STA	ICBLL
	LDA	MNL+1
	STA	ICBLH
	JSR	DSPMSG	;SHOW MENU
;
;	SELECT ITEM FROM MENU
;	FUNCTION COME HERE WHEN THEY ARE DONE.
;
MENUSL	LDX	#$FF	;RESET STACK AT THIS POINT
	TXS
	BIT	RDM	;IF WE SHOULD SHOW MENU
	BMI	PBMEN	;GO DO IT
	LDA	#SITL	;SELECT ITEM MESSAGE
	LDX	#SITH
	JSR	DSPLIN
	LDA	#$40	;MAKE SURE UPPER CASE
	STA	SHFLOK
	JSR	CHRGET		;GO GE KEYBOARD CHAR.
	SEC
	SBC	#"A"		;CONVERT ASCII CHAR. TO BINARY # & SUBTRACT 1
	BMI	RANGE		;IF ASCII CHAR NOT  3, GO READ AGAIN
	CMP	MENUSZ		;IS THE # ENTERED > MENU SIZE?
	BPL	RANGE		;IF YES, GO READ AGAIN
	ASL
	TAY			;SET INDEX TO (MENU # - 1) * 2
	LDA	(JMPTBL_),Y
	INY
	STA	RAMLO	;GET STRING POINTER
	LDA	(JMPTBL_),Y

	STA	RAMLO+1
	LDY	#1	;LOAD STRING POINTER INTO REGISTERS
	LDA	(RAMLO),Y	;FOR DSPLIN
	TAX
	DEY
	LDA	(RAMLO),Y
	JSR	DSPLIN	;PRINT MODULES INITIAL STRING
	LDA	RAMLO	;INC BY 2 TO POINT PAST STRING POINTER
	CLC
	ADC	#2
	STA	RAMLO
	LDA	RAMLO+1
	ADC	#0	;CARRY
	STA	RAMLO+1	;PUT HI BYTE.
	JMP	(RAMLO)	;JUMP TO ROUTINE SELECTED BY MENU.
RANGE	LDA	#NBIL
	LDX	#NBIH
	JSR	DSPLIN	;NO SUCH ITEM MESSAGE
	JMP	MENUSL
NBI	.BYTE	"NO SUCH ITEM",CR
SIT	.BYTE	"SELECT ITEM",CR
	;HILO	NBI
NBIH	=	NBI/256
NBIL	=	-256*NBIH+NBI
	;HILO	SIT
SITH	=	SIT/256
SITL	=	-256*SITH+SIT
MNSL	=	MENUSL
	;HILO	MNSL
MNSLH	=	MNSL/256
MNSLL	=	-256*MNSLH+MNSL
;
; PAUSE AND REDISPLAY MENU
;
PBMEN	LDA	#0
	STA	ICBLH
	LDA	#21
	STA	ICBLL
	LDA	#PMESH
	STA	ICBAH
	LDA	#PMESL
	STA	ICBAL
	JSR	DSPMSG
	JSR	CHRGET
	JMP	SHMEN
PMES	.BYTE	CR,"TYPE RETURN FOR MENU"
	;HILO	PMES

PMESH	=	PMES/256
PMESL	=	-256*PMESH+PMES
;
;
;	DIRECTORY LISTING ROUTINE
;
DIRLST	.WORD	DLMG
	JSR	GETICI
	LDX	PTR
	LDA	#CR
	STA	PAR-1,X	;ASSURE GOOD TERM
	LDA	PAR-2,X	;LAST CHAR OF SEARCH SPEC
	CMP	#":"	;IF COLON, ADD *.*
	BNE	DLF
	LDA	#"*"
	STA	PAR-1,X
	STA	PAR+1,X
	LDA	#"."
	STA	PAR,X
	LDA	#CR
	STA	PAR+2,X
	INX
	INX
	INX
	STX	PTR
DLF	STX	SAVX
	LDX	#$20
	JSR	PIOCB
	JSR	GETFIL
	JSR	PERX
	LDA	#6	;READ DIR INFO
	LDX	#$10
	STA	ICAX1,X
	LDA	#OPEN	;OPEN
	STA	ICCOM,X
	STX	CSRC	;COPY SOURCE=DIRECTORY INFO
	CPX	#$10
	BNE	*+5	;[Fixed bug: was *+3, but must skip this instruction and the next]
	JSR	CIOCL
	LDA	PTR
	SEC
	SBC	SAVX
	CMP	#3	;IF ONLY 3 CHARS; IS "D:"CR, USE DEFAULT
	BEQ	DLST1
DLST0	JMP	PDES	;GO INTO COPY
DLST1	LDX	SAVX
	LDA	PAR,X
	CMP	#"D"
	BNE	DLST0
	JMP	PDES1	;GO INTO COPY WITH DEB='E:'
DLMG	.BYTE	"DIRECTORY--SEARCH SPEC,LIST FILE?",CR

DELFIL	.WORD	DEMG
	JSR	GETICI
	JSR	PERX	;EXIT IF PARAM ERRORS
	LDA	PAR	;GET DEVICE
	CMP	#"D"	;ONLY ALLOW DELETE FROM D:
	BEQ	DF1
	LDA	#NDFL
	LDX	#NDFH
	JSR	DSPLIN
	JMP	MENUSL
NDF	.BYTE	"NOT A DISK FILE",CR
	;HILO	NDF
NDFH	=	NDF/256
NDFL	=	-256*NDFH+NDF
DF1	LDX	#$10
	LDA	OPT
	CMP	#"N"	;IF OPTION=N, NO QUERY
	BNE	DNO	;NO DELETE WITH QUERY
	LDA	#DELETE
	STA	ICCOM,X
	JSR	CIOCL
	JMP	MENUSL
DNO	LDA	#TYDL
	LDX	#TYDH
	JSR	DSPLIN	;SAY Y TO DELETE
	LDA	#0
	STA	IPTR	;HOW MANY FILES TO SKIP, NONE AT FIRST
	LDX	#$20	;SET UP DELETE IOCB
	LDA	#DELETE
	STA	ICCOM,X
	LDA	#DB3L
	STA	ICBAL,X
	LDA	#DB3H
	STA	ICBAH,X
	LDA	#"D"
	STA	DBUF-3
	LDA	#":"
	STA	DBUF-1
	LDA	PAR+1
	CMP	#":"
	BNE	*+4
	LDA	#"1"
	STA	DBUF-2	;KLUDGE KLUDGE KLUDGE
IDRD	LDX	#$10
	LDA	#$03

	STA	ICCOM,X
	LDA	#6
	STA	ICAX1,X	;DIR READ OPEN
	LDA	#PARL
	STA	ICBAL,X
	LDA	#PARH
	STA	ICBAH,X
	JSR	CIOCL
	LDA	#DBUFL
	STA	ICBAL,X
	LDA	#DBUFH
	STA	ICBAH,X
	LDA	#GETRCD
	STA	ICCOM,X
	LDA	#0
	STA	PTR	;HOW MANY FILES WE HAVE SKIPPED
; READ FILENAME FROM DIR, QUERY AND DELETE
RDFN	LDX	#$10
	LDA	#0
	STA	ICBLL,X
	LDA	#1
	STA	ICBLH,X
	JSR	CIOCL	;READ A LINE FROM DIRECTORY
	LDA	DBUF+1	;IF FILE LINE, THIS IS BLANK
	CMP	#" "
	BNE	DELX	;THIS IS FREE BLOCKS LINE
	INC	PTR	;COUNT THIS FILE
	LDA	PTR	;HAVE WE SKIPPED ENUF YET
	CMP	IPTR
	BMI	RDFN	;BR IF NO
	LDX	#0	;PUT PTR
	LDY	#2	;GET PTR
; MASSAGE DELETE FILE NAMES
MDN1	LDA	DBUF,Y
	CMP	#" "	;END OF FILENAME
	BEQ	MDN2
	STA	DBUF,X
	INX
	INY
	CPX	#8
	BMI	MDN1
;FILENAME IS MOVED, PUT .EXT
MDN2	LDA	#"."
	STA	DBUF,X
	INX
	LDY	#10	;WHERE EXT IS
MDN3	LDA	DBUF,Y
	STA	DBUF,X
	INY
	INX
	CPY	#13
	BMI	MDN3
	STX	SAVX	;PUT CR HERE LATER .
	LDA	#"?"	;FOR QUERY
	STA	DBUF,X
	INX
	LDA	#CR
	; [ next three instructions missing from bottom of page]
	STA	DBUF,X
	LDA	#DB3L
	LDX	#DB3H

	JSR	DSPLIN	;GO ASK ABOUT THIS FILE
	JSR	CHRGET
	CMP	#$59
	BNE	RDFN	;GO DO NEXT FILENAME
	LDA	PTR	;NUMBER FILES WE HAVE GONE THRU SO FAR
	STA	IPTR	;IS NEW NUMBER TO SKIP
	LDX	SAVX
	LDA	#CR
	STA	DBUF,X
	LDX	#$20	;DELETE IOCB
	JSR	CIOCL
	JSR	CLOS1
	JMP	IDRD	;CLOSE AND REOPEN DIR READ FILE
DELX	JSR	CLOS1	;CLOSE DIR READ FILE
	JMP	MENUSL
CLOS1	LDX	#$10
	LDA	#CLOSE
	STA	ICCOM,X
	JMP	CIOCL
	;RTS
TYD	.BYTE	"TYPE ",$22,"Y",$22," TO DELETE...",CR
	;HILO	TYD
TYDH	=	TYD/256
TYDL	=	-256*TYDH+TYD
DEMG	.BYTE	"DELETE FILE SPEC",CR
;***************
;
;
;	COPY FILE ROUTINE
;***************
CPMG	.BYTE	"COPY--FROM, TO?",CR
DE	.BYTE	"OPTION DOESNT MAKE SENSE",CR
	;HILO	DE
DEH	=	DE/256

DEL	=	-256*DEH+DE
CPYFIL	.WORD	CPMG
	JSR	GETICI
	LDA	OPT
	PHA
	LDX	PTR
	DEX
	LDA	#CR	;TERM FIRST FILENAME
	STA	PAR,X
	LDX	#$20	;IOCB 3
	JSR	PIOCB
	LDA	PTR
	STA	SAVX
	JSR	GETFIL	;GET SECOND FILENAME
	JSR	PERX	;IF PARAM ERRS, EXIT
PSRC	PLA
	TAX
	LDA	PAR	;GET 1ST LETR OF PARAM
	CMP	#"K"	;K AND E AS SOURCE ARE SPECIAL
	BEQ	ODMS	;K: GETS 'OPTION DOESNT MAKE SENSE' FOR NOW
	CMP	#"E"
	BNE	OPSRC	;IF NO THEN OPEN SOURCE FILE
	DEC	RDM	;E: SO RESHOW MENU AFTER COPY
	LDX	#0
	STX	CSRC
	JMP	PDES
OPSRC	CMP	#"S"
	BEQ	ODMS	;S: AS SOURCE GETS O.D.M.B. FOR NOW
	CPX	#"S"
	BNE	OPSRC1
	CMP	#"C"
	BNE	ODMS
	LDA	#$80
	STA	ICAX2+$10
OPSRC1	LDX	#$10
	LDA	#OPEN
	STA	ICCOM,X
	LDA	#4	;OPEN IN
	STA	ICAX1,X
	STX	CSRC
	CPX	#$10
	BNE	OPSRCX	;*+33	;[OPSRCX - JMP MENUSL]
	JSR	CIOCL	;OPEN SOURCE FILE HERE
PDES	LDX	SAVX
	LDA	PAR,X
	CMP	#"E"	;CHECK FOR SPECIAL CASE
	BNE	OPDES	;IF NOT
PDES1	LDA	#0	;SPECIAL CASE - DONT OPEN, USE EXISTING IOCB
	STA	CDES
	DEC	RDM	;SET FLAG TO RESHOW MENU
	JMP	DOCPY
ODMS	LDA	#DEL
	LDX	#DEH
	JSR	DSPLIN
OPSRCX	JMP	MENUSL	;[label added]
OPDES	CPX	#"A"	;APPEND TO DISK FILE
	BNE	OPDES1
	CMP	#"D"
	BNE	ODMS
	LDA	#$09

	BNE	OPDES3
OPDES1	LDA	#8
OPDES3	LDX	#$20
	STA	ICAX1,X	;OPEN TYPE OUT
	LDA	#OPEN
	STA	ICCOM,X	;OPEN
	STX	CDES
	JSR	CIOCL
	LDA	#0
	STA	ICAX2,X
;COPY FROM CSRC TO CDES
DOCPY	LDA	#GETCHR+TEXT
	LDX	CSRC
	LDY	CDES
	STA	ICCOM,X
	LDA	#PUTCHR+TEXT
	STA	ICCOM,Y
	LDA	#DBUFL
	STA	ICBAL,X
	STA	ICBAL,Y
	LDA	#DBUFH
	STA	ICBAH,X
	STA	ICBAH,Y
CLOOP	LDX	CSRC
	LDA	#$00
	STA	ICBLL,X
	LDA	#$01
	STA	ICBLH,X
	JSR	CIO	;READ FROM INPUT
	STY	SSTAT
	LDX	CDES
	LDY	CSRC
	LDA	ICBLL,Y
	STA	ICBLL,X
	LDA	ICBLH,Y
	STA	ICBLH,X
	ORA	ICBLL,Y	;IF SOURCE FILE LENGTH = 0
	BEQ	CKRS	;DONT DO WRITE
	JSR	CIOCL	;WRITE, ABORT IF ERROR
CKRS	LDA	SSTAT	;GET READ OPERATION STATUS BACK
	BPL	CLOOP	;IF OK, GO READ SOME MORE
	CMP	#$88	;EOF STATUS
	BEQ	CLOC	; was: *+5
	JMP	CIOER	;IF NOT, ABORT
CLOC	LDX	CSRC
	BEQ	DU4	;IF E:, DONT CLOSE
	CPX	#$30	;OR K:
	BEQ	DU4
	LDA	#CLOSE
	STA	ICCOM,X
	JSR	CIO
DU4	LDX	CDES
	BEQ	DU3	;IF DES=E:
	LDA	#CLOSE
	STA	ICCOM,X
	JSR	CIO
DU3	JMP	MENUSL
;***************
;

;	RENAME FILE ROUTINE
;
;***************
RENFIL	.WORD	RNMG
	JSR	GETICI
	JSR	GETNAME
	JSR	PERX
	LDA	#RENAME
	LDX	#$10
	STA	ICCOM,X
	JSR	CIOCL
	JMP	MENUSL
RNMG	.BYTE	"RENAME, GIVE OLD NAME, NEW",CR
;***************
;
;
;
;
;	FORMAT DISK ROUTINE
;
;***************
FMTDSK	.WORD	WHD
	JSR	GETLIN
	JSR	GETDN
	CLC
	ADC	#"0"
	STA	DDSK
	STA	CDSK
	JSR	PERX
	LDA	#VFML	;QUERY TO VERIFY DRIVE NUMBER
	LDX	#VFMH
	JSR	DSPLIN
	JSR	CHRGET
	CMP	#"Y"	;SEE IF OK
	BNE	FMX
	LDA	#FDPL
	LDX	#$10
	STA	ICBAL,X
	LDA	#FDPH
	STA	ICBAH,X
	LDA	#FORMAT
	STA	ICCOM,X
	JSR	CIOCL	;CALL CIO TO DO FORMAT
FMX	JMP	MENUSL	;EXIT
WHD	.BYTE	"WHICH DRIVE TO FORMAT?",CR

VFM	.BYTE	"TYPE ",$22,"Y",$22," TO FORMAT DISK "
DDSK	.BYTE	0	;[save a byte for the drive number, '2' in my binary]
	.BYTE	CR
FDP	.BYTE	"D"
CDSK	.BYTE	0	;[save a byte for the drive number, '2' in my binary]
	.BYTE	":",CR
	;HILO	WHD
WHDH	=	WHD/256
WHDL	=	-256*WHDH+WHD
	;HILO	VFM
VFMH	=	VFM/256
VFML	=	-256*VFMH+VFM
	;HILO	FDP
FDPH	=	FDP/256
FDPL	=	-256*FDPH+FDP
;***************
;
;	START CART ROUTINE
;
;***************
SYVBL	=	SYSVBV
	;HILO	SYVBL
SYVBLH	=	SYVBL/256
SYVBLL	=	-256*SYVBLH+SYVBL
XTVBL	=	XITVBV
	;HILO	XTVBL
XTVBLH	=	XTVBL/256
XTVBLL	=	-256*XTVBLH+XTVBL
STCAR	.WORD	SCMG
	LDA	$BFFC	;SEE IF CART
	BEQ	ISCAR	;GO IF THERE IS
	LDA	#NCAL
	LDX	#NCAH	;SAY NO CART
	JSR	DSPLIN
	JMP	MENUSL
ISCAR	JSR	INITIO
; 	RESET VERTICAL BLANK VECTORS BEFORE ENTERING CART
	LDA	#6	;SET VVBLKI
	LDX	#SYVBLH	;HI BYTE
	LDY	#SYVBLL
	JSR	SETVBV
	LDA	#7	;SET VVBLKD
	LDX	#XTVBLH
	LDY	#XTVBLL
	JSR	SETVBV
	JMP	(CARTST)
NCA	.BYTE	"NO CARTRIDGE",CR
	;HILO	NCA
NCAH	=	NCA/256

NCAL	=	-256*NCAH+NCA
SCMG	.BYTE	CR
;
;
BRUN	.WORD	BRMG
	JSR	GETLIN
	JSR	GETNO
	JSR	PERX
	STA	RAMLO
	STX	RAMLO+1
	JMP	(RAMLO)
BRMG	.BYTE	"RUN FROM WHAT ADDRESS?",CR
;
; DEFINE DEVICE
;
DEDE	.BYTE	"LOGICAL DEVICE, PHYSICAL DEVICE?",CR
DEFDEV	.WORD	DEDE
	JSR	GETLIN
	JSR	GETFIL	;GET LOGICAL DEVICE NAME
	LDA	PTR
	CMP	#3	;SHOULD BE DEVICE NAME ONLY
	BNE	BS1	;BAD SYNTAX
	JSR	GETFIL	;GET PHYSICAL DEVICE
	JSR	PERX
	LDA	PAR	;GET LOG DEV
	JSR	HATS	;SEARCH HAT (HANDLER ADDRESS TABLE)
	BPL	DD1	;IF FOUND
;DIDNT FIND IT SO FIND EMPTY SLOT
	LDA	#0
	JSR	HATS
	BMI	STF	;TABLE IS FILLED
	LDA	PAR
	STA	HATABS,X  PUT NAME IN TABLE
DD1	LDA	#DRHL
	STA	HATABS+1,X
	LDA	#DRHH
	STA	HATABS+2,X
	STX	SAVX
;SET UP LDNT,PDST ENTRIES
	LDA	PAR	;GET DEVICE
	JSR	FLDB
	BPL	SV1	;IF FOUND IT

	LDA	#0
	JSR	FLDB
	BPL	SV2
;NO ROOM IN TABLE
STF	LDA	#TFL
	LDX	#TFH
DSX	JSR	DSPLIN
	JMP	MENUSL
TF	.BYTE	"TABLE FULL",CR
	;HILO	TF
TFH	=	TF/256
TFL	=	-256*TFH+TF
BS2
BS1
	LDA	#BSML
	LDX	#BSMH
	BNE	DSX
BSM	.BYTE	"CANT DEFINE THIS DEVICE",CR
	;HILO	BSM
BSMH	=	BSM/256
BSML	=	-256*BSMH+BSM
SV2	LDA	PAR
	STA	LDNT,X
;SEE NOW IF THIS IS A DELETE
SV1	LDA	PAR+2
	CMP	#CR
	BNE	CRD	;NO, GO CREATE DEVICE
;DELETE OPERATION, ZERO LDNT AND HAT ENTRIES
	LDA	#0
	STA	LDNT,X
	LDX	SAVX
	STA	HATABS,X
	JMP	MENUSL
;CREATE DEVICE - HAT AND LDNT ARE SET UP, MAKE PDST ENTRY
CRD	TXA
	ASL
	ASL
	ASL
	ASL
	TAX
	LDY	#0
CPSL	LDA	PAR+3,Y	;GET BYTE OF PHYSICAL DEV:FILESPEC
	STA	PDST,X	;STORE IN TABLE
	INX
	INY
	CPY	#16
	BNE	CPSL
	JMP	MENUSL
;HATS FINDS DEVICE NAMED IN A, RETURNS ITS INDEX IN X

HATS	LDX	#MAXDEV
HATSL	CMP	HATABS,X
	BEQ	HATX
	DEX
	DEX
	DEX
	BPL	HATSL
HATX	RTS
;FLDB IS THE SAME THING FOR LDNT
FLDB	LDX	#4
FLL	CMP	LDNT,X
	BEQ	FLDX
	DEX
	BPL	FLL
FLDX	RTS
;	
; WBOOT - WRITE OUT NEW DOS.SYS FILE
;	
WBOOT	.WORD	OWMG
	JSR	CHRGET
	CMP	#"Y"
	BNE	WBX	;EXIT UNLESS Y
	LDA	#WBMGL
	LDX	#WBMGH
	JSR	DSPLIN
	LDA	#OPEN
	LDX	#$10
	STA	ICCOM,X
	LDA	#DSL
	STA	ICBAL,X
	LDA	#DSH
	STA	ICBAH,X
	LDA	#8
	STA	ICAX1,X
	JSR	CIOCL
	LDX	#$10
	LDA	#CLOSE
	STA	ICCOM,X
	JSR	CIOCL
WBX	JMP	MENUSL
WBMG	.BYTE	"WRITING NEW DOS.SYS FILE",CR
	;HILO	WBMG
WBMGH	=	WBMG/256
WBMGL	=	-256*WBMGH+WBMG
OWMG	.BYTE	"TYPE ",$22,"Y",$22," TO WRITE NEW DOS FILE",CR

DS	.BYTE	"D:DOS.SYS",CR
	;HILO	DS
DSH	=	DS/256
DSL	=	-256*DSH+DS
;
;
;
; LDFIL - LOAD FILE FUNCTION
;
LDFIL	.WORD	LFMG
	JSR	GETICI
	JSR	PERX
	JSR	LOAD
	CPX	#0	;PROCESS LOAD SUBR RESPONSE
	BEQ	LDFX	;BR IF ERRORS (any JMP MENUSL line)
	CPX	#3
	BEQ	NLF	;IF BAD LOAD FILE
	TYA		;OTHERWISE WE GOT A CIO ERROR
	JMP	CIOER	;GO SAW WHAT IT IS
NLF	LDA	#BLFL
	LDX	#BLFH
	JSR	DSPLIN	;BAD LOAD FILE MSG
	JSR	CLOSX	;CLOSE THE FILE
LDFX	JMP	MENUSL	;EXIT
BLF	.BYTE	"BAD LOAD FILE",CR
	;HILO	BLF
BLFH	=	BLF/256
BLFL	=	-256*BLFH+BLF
LFMG	.BYTE	"LOAD FROM WHAT FILE?",CR
;
; LKFILE - DO CIO LOCK
;
LKFIL	.WORD	LKMG
	JSR	GETICI
	JSR	PERX
	LDA	#LOCK
	LDX	#$10
	STA	ICCOM,X

	JSR	CIOCL
	JMP	MENUSL
LKMG	.BYTE	"WHAT FILE TO LOCK?",CR
;
; ULFIL - DO CIO UNLOCK
ULFIL	.WORD	ULMG
	JSR	GETICI
	JSR	PERX
	LDA	#UNLOCK
	LDX	#$10
	STA	ICCOM,X
	JSR	CIOCL
	JMP	MENUSL
ULMG	.BYTE	"WHAT FILE TO UNLOCK?",CR

DDMG	.BYTE	"DUP DISK-SOURCE,DEST DRIVES?",CR
OK	.BYTE	"TYPE ",$22,"Y",$22," IF OK TO USE PROGRAM AREA",CR
	;HILO	OK
OKH	=	OK/256
OKL	=	-256*OKH+OK
;****************
;
;
;
;
;	DUPLICATE DISK ROUTINE
;
;
;*************
;
;	RVTOC READS VOLUME TABLE OF CONTENTS SECTOR
;
RVTOC	LDA	#1
	STA	DSHI	;READ VTOC SECTOR
	LDA	#$68
	STA	DSLO
	LDA	#DB1H
	STA	DBUFHI
	LDA	#DB1L
	STA	DBUFLO	;POINT DCB AT PAR
	JSR	RSEC1
	LDA	#0
	STA	PTR
	LDA	PAR+$A
	STA	CSRC	;BYTE OF ALLOC MAP
	LDA	#8
	STA	IPTR	;COUNT BITS IN BYTE
	LDA	#0
	STA	DSHI	;POINT T SECTOR ONE
	LDA	#1
	STA	DSLO
	RTS
;
;
; (comment missing from bottom of listing page)
DUPDSK	.WORD	DDMG

	JSR	GETLIN
	JSR	GETDN
	STA	UNNO	;UNIT NO FOR READ
	JSR	GETDN
	STA	CDES
	JSR	PERX
	LDA	UNNO
	CMP	CDES	;IF BOTH UNITS THE SAME
	BEQ	SDD	;SINGLE DRIVE DUP
	LDX	#IBDH
	LDA	#IBDL
	JSR	DSPLIN	;PROMPT TO INSERT BOTH DISKS
	JSR	CHRGET
	JSR	RVTOC
NSEC	JSR	AAM	;ADV ALLOC MAP ONE BIT
	BMI	CEND
	JSR	RSEC
	LDA	CDES	;UNIT TO WRITE TO
	STA	DUNIT
	JSR	DKWAT
CEND	JSR	ASP
	BNE	NSEC	;IF MORE SECTORS
	JMP	MENUSL	;DONE
IBD	.BYTE	"INSERT BOTH DISKS, TYPE RETURN",CR
	;HILO	IBD
IBDH	=	IBD/256
IBDL	=	-256*IBDH+IBD
;SINGLE DRIVE DISK DUP
;
;FIND AVAIL MEMORY, FILL FROM SOURCE DISK, SWAP, EMPTY, SWAP, REPEAT.
;
SDD	LDA	MEMLO	;END OF DUP
	STA	STVEC
	LDA	MEMLO+1
	STA	STVEC+1
	LDA	MEMTOP
	SEC
	SBC	#$80	;END-128 TO SEE IF ROOM
	STA	T1	;FOR ANOTHER SECTOR
	LDA	MEMTOP+1
	SBC	#0
	STA	T1+1
;SEE IF ROOM FOR AT LEAST ONE SECTOR!
	LDA	T1+1
	CMP	STVEC+1
	BMI	NORM
	BNE	ENUF
	LDA	T1
	CMP	STVEC
	BPL	ENUF

NORM	LDA	#NRML
	LDX	#NRMH
	JSR	DSPLIN
	JMP	MENUSL
ENUF	JSR	CKMEM	;SEE IF OK TO USE USER AREA
	LDA	#0
	STA	OPT	;SET UP FOR READ HERE FIRST PASS
	LDA	#ISDL
	LDX	#ISDH
	JSR	DSPLIN
	JSR	CHRGET
	JSR	RVTOC	;READ VTOC AFTER 1ST INSERT SOURCE MSG
	LDA	DSLO	;COPY INITIAL WRITE POINTERS
	STA	SWDP	;TO INITIAL READ POINTERS
	LDA	DSHI
	STA	SWDP+1
	LDA	PTR
	STA	SWDP+2
	LDA	IPTR
	STA	SWDP+3
	LDA	CSRC
	STA	SWDP+4
	JMP	LRS1	;SKIP FIRST READ PROMPT
;READ FROM SOURCE DISK TIL BUF FULL OR END OF DATA
DORD	LDA	#0	;FLAG WE ARE READING
	STA	OPT
	LDA	#ISDL	;INSERT SRC DISK
	LDX	#ISDH
XBLK	JSR	DSPLIN
	JSR	CHRGET
;SWAP POINTERS TO WHERE WE ARE
LRS1	JSR	DOSWDP	;SWAP SECTOR AND BITMAP POINTERS
;LOOP READING/WRITING SECTORS TO BUFFER AREA
LRS	JSR	AAM	;ADVANCE ALLOCATION MAP
	BMI	ASPT	;IF FREE, ADVANCE SECTOR POINTER AND TRY AGIN
	BIT	OPT	;SEE WHAT MODE
	BMI	DOW	;BR IF WRITE
	JSR	RSEC1	;DO READ
	JMP	IOD
DOW	JSR	DKWAT	;DO WRITE
IOD	LDA	DBUFLO	;ADVANCE BUFFER POINTER
	CLC
	ADC	#$80
	STA	DBUFLO
	LDA	DBUFHI
	ADC	#$00
	STA	DBUFHI
ASPT	JSR	ASP	;GO ADVANCE SECTOR POINTER
	BEQ	STDD1	;ALL SECTORS DONE, SWAP TO DEST DISK
	LDA	T1+1	;SEE IF ROOM FOR ANOTHER
	CMP	DBUFHI
	BMI	STDD	;IF NO ROOM, GO SWAP
	BNE	LRS	;ROOM SO CONTINUE
	LDA	T1
	CMP	DBUFLO
	BPL	LRS	;ROOM
;SWAP DISKS AND CONTINUE
STDD	LDA	OPT
	BMI	DORD	;IF WAS WRITE, GO READ
STDD2	DEC	OPT

	LDA	#IDDL	;INSERT DEST DISK
	LDX	#IDDH
	JMP	XBLK	;GO DO WRITE
STDD1	LDA	OPT	;END OF DATA
	BPL	STDD2	;IF READ GO WRITE
	JMP	MENUSL	;IF WRITE WE ARE DONE
;DOSWDP - EXCHANGE CURRENT AND SAVED BITMAP&SECTOR POINTERS
; ALSO INIT BUFFER POINTER
DOSWDP	LDY	#4
SWLOP	LDA	SWATL,Y
	STA	RAMLO
	LDA	SWATH,Y
	STA	RAMLO+1	;GET ADDRESS FROM TABLE TO RAMLO
	LDX	#0
	LDA	(RAMLO,X)	;GET WHATS THERE
	PHA
	LDA	SWDP,Y
	STA	(RAMLO,X)
	PLA
	STA	SWDP,Y
	DEY
	BPL	SWLOP
	LDA	STVEC
	STA	DBUFLO
	LDA	STVEC+1
	STA	DBUFHI
	RTS
;
;	WHAT A MESS
;
	;HILO	DSLO
DSLOH	=	DSLO/256
DSLOL	=	-256*DSLOH+DSLO
	;HILO	DSHI
DSHIH	=	DSHI/256
DSHIL	=	-256*DSHIH+DSHI
	;HILO	PTR
PTRH	=	PTR/256
PTRL	=	-256*PTRH+PTR
	;HILO	IPTR
IPTRH	=	IPTR/256
IPTRL	=	-256*IPTRH+IPTR
	;HILO	CSRC
CSRCH	=	CSRC/256
CSRCL	=	-256*CSRCH+CSRC
;
SWATL	.BYTE	DSLOL,DSHIL,PTRL,IPTRL,CSRCL
SWATH	.BYTE	DSLOH,DSHIH,PTRH,IPTRH,CSRCH
;
NRM	.BYTE	"NOT ENOUGH ROOM",CR
ISD	.BYTE	"INSERT SOURCE DISK,TYPE RETURN",CR

IDD	.BYTE	"INSERT DESTINATION DISK,TYPE RETURN",CR
	;HILO	NRM
NRMH	=	NRM/256
NRML	=	-256*NRMH+NRM
	;HILO	ISD
ISDH	=	ISD/256
ISDL	=	-256*ISDH+ISD
	;HILO	IDD
IDDH	=	IDD/256
IDDL	=	-256*IDDH+IDD
; AAM - ADVANCE ALLOCATION MAP ONE BIT.
; RETURN MINUS IF FREE.
AAM	ASL	CSRC	;NEXT BIT OF ALLOC MAP
	DEC	IPTR
	BNE	CBIT	;IF DONE WITH THIS BYTE
	INC	PTR	;GET NEXT ONE
	LDX	PTR
	LDA	DB1+$A,X
	STA	CSRC
	LDA	#8
	STA	IPTR
CBIT	LDA	CSRC	;CHECK THE BIT
DRTS	RTS
; ASP - ADVANCE SECTOR POINTER IN DCB.
; RETURN EQ IF AT END.
ASP	LDA	DSLO	;SEE IF END
	CMP	#207
	BNE	NXS
	LDA	DSHI
	CMP	#2
	BEQ	ASPX	;ALL DONE
NXS	INC	DSLO
	BNE	ASPX
	INC	DSHI
ASPX	RTS
;
; RSEC - READ A SECTOR WHOSE NUMBER IS IN DCB
;
RSEC	LDA	#DBUFL
	STA	DBUFLO
	LDA	#DBUFH

	STA	DBUFHI
RSEC1	LDA	UNNO
	STA	DUNIT
	LDA	#$52	;GET SECTOR
	JMP	CLDKH
;
; DKWRT - WRITE A SECTOR, NUMBER IN DCB
;
DKWAT	LDA	#$57
CLDKH	STA	DCOMND
	LDA	#2	;SET RETRY COUNT
	STA	RCNT
CLD1	JSR	DKHND
	LDA	DSTATS
	CMP	#1
	BEQ	DRTS	;OK STATUS
	DEC	RCNT
	BPL	CLD1
	JMP	CIOER	;CIO ERROR, GO SAY WHICH
;DRTS	RTS	; use a different RTS above
;
;	CKMEM - ASK IF OK TO USER USER AREA
;
;DDXT	PLA		;POP RETURN ADDRESS
;	PLA
;	JMP	MENUSL
CKMEM	LDA	WARMST	;IF MEMORY WAS INTACT
	BEQ	CPTR1	;QUERY TO BOMB IT
	LDA	#OKL
	LDX	#OKH
	JSR	DSPLIN
	JSR	CHRGET
	CMP	#"Y"
	BNE	DDXT
	LDA	#0
	STA	WARMST
CPTR1	RTS
; [CKMEM moved down to eliminate redundant code]

;
;	DUPFIL - COPY FILE FROM ONE DISK TO ANOTHER
;
DPFM	.BYTE	"NAME OF FILE TO MOVE?",CR
DUPFIL	.WORD	DPFM
	JSR	GETICI	;GET A DEV:FILSPEC
	JSR	PERX	;CHECK FOR ERRORS
	JSR	CKMEM
	LDX	#$10
	LDA	#OPEN
	STA	ICCOM,X
	LDA	#4
	STA	ICAX1,X
	JSR	CIOCL
	LDA	MEMTOP	;SET BUFFER LENGTH
	SEC		;TO ALL AVAILABLE MEMORY
	SBC	MEMLO
	STA	ICBLL,X
	LDA	MEMTOP+1
	SBC	MEMLO+1
	STA	ICBLH,X
	LDA	MEMLO
	STA	ICBAL,X
	LDA	MEMLO+1
	STA	ICBAH,X
	LDA	#GETCHR
	STA	ICCOM,X
	JSR	CIO
	CPY	#$88
	BEQ	OKS	;IF EOF, WE READ WHOLE FILE SO OK
	CPY	#1
	BEQ	*+5
	JMP	CIOER1	;NOT OK OR EOF SO GIVE ERROR MESSAGE
	LDA	#NRML	;OK, SAY NO ROOM
	LDX	#NRMH
	JSR	DSPLIN
DFCX	LDA	#CLOSE
	LDX	#$10
	STA	ICCOM,X
	JSR	CIO
DDXT	=*	; any JML MENUSL within range
	JMP	MENUSL
OKS	LDA	#CLOSE
	LDX	#$10
	STA	ICCOM,X
	LDA	ICBLL,X
	STA	T1
	LDA	ICBLH,X
	STA	T1+1
	JSR	CIO
	LDX	#IDDH
	LDA	#IDDL
	JSR	DSPLIN	;SAY TO SWAP DISKS
	JSR	GETLIN

	LDX	#$10
	LDA	#PARL
	STA	ICBAL,X POINT TO FILENAMEAGAIN
	LDA	#PARH
	STA	ICBAH,X
	LDA	#OPEN
	STA	ICCOM,X
	LDA	#8
	STA	ICAX1,X
	JSR	CIOCL	;OPEN FOR OUTPUT
	LDA	MEMLO
	STA	ICBAL,X
	LDA	MEMLO+1	;SET UP ADR AND LENGTH
	STA	ICBAH,X
	LDA	T1
	STA	ICBLL,X
	LDA	T1+1
	STA	ICBLH,X
	LDA	#PUTCHR
	STA	ICCOM,X
	JSR	CIOCL	;DO THE WRITE
	JMP	DFCX	;CLOSE AND EXIT
;**************
;
;
;	SAVE FILE ROUTINE
;
;************
MENUSL1	JMP	MENUSL	; no other MENUSL in range of the branch
SAVFIL	.WORD	SFMG
	JSR	GETICI
	LDA	OPT
	PHA
	LDX	PTR	;PUT EOL ON FILENAME
	LDA	#CR
	STA	PAR-1,X
	JSR	GETNO	;GET HEX PARAMETER
	STA	LDST
	STX	LDST+1
	JSR	GETNO	;END ADDRESS
	STA	LDND
	STX	LDND+1
	BIT	PER_	;SEE IF PARAM ERRORS
	BMI	MENUSL1	;IF ERRORS (any MENUSL target)
	LDA	#0
	STA	OPT
	PLA		;OPTION CHAR FROM FILENAME
	CMP	#"A"	;IF APPEND
	BNE	*+5
	DEC	OPT	;SET OT=$FF
; OPEN THE FILE
	LDX	#$10
	LDA	#OPEN
	STA	ICCOM,X
	BIT	OPT	;IF APPEND
	BMI	*+6
	LDA	#8
	BNE	*+4
	LDA	#9
	STA	ICAX1,X

	JSR	CIOCL
; WRITE SAVE FILE HEADER
	LDX	#$10
	LDA	#PUTCHR
	STA	ICCOM,X
	BIT	OPT	;IF APPEND,
	BMI	WDR	;DONT WRITE ANOTHER HEADER
	LDA	#SAVHL
	STA	ICBAL,X
	LDA	#SAVHH
	STA	ICBAH,X
	LDA	#2
	STA	ICBLL,X
	LDA	#0
	STA	ICBLH,X
	JSR	CIOCL
; WRITE DATA RECORD
WDR	LDX	#$10
	LDA	#4
	STA	ICBLL,X
	LDA	#0
	STA	ICBLH,X
	LDA	#DTHL	;DATA RECORD HEADER
	STA	ICBAL,X
	LDA	#DTHH
	STA	ICBAH,X
	JSR	CIOCL	;NO. WRITE DATA REC HDR
	LDX	#$10
	SEC
	LDA	LDND
	SBC	LDST
	STA	ICBLL,X
	LDA	LDND+1
	SBC	LDST+1
	STA	ICBLH,X
	INC	ICBLL,X
	BNE	*+5
	INC	ICBLH,X
	LDA	LDST
	STA	ICBAL,X
	LDA	LDST+1
	STA	ICBAH,X
	JSR	CIOCL	;WRITE THE DATA
	LDX	#$10
	LDA	#CLOSE
	STA	ICCOM,X
	JSR	CIOCL
	JMP	MENUSL	;DONE
SFMG	.BYTE	"SAVE--GIVE FILE, START, END",CR
;
;		S U B R O U T I N E S
;
;
;
;
; INITIO - CLOSE ANY OPEN IOCBS
;
INITIO	LDX	#$70
IIO1	LDA	ICHID,X
	CMP	#$FF	;CHECK FOR CLOSED IOCB
	BEQ	NXIOCB	;ALREADY CLOSED, CHECK NEXT ICOB
	LDA	#CLOSE
	STA	ICCOM,X
	JSR	CIO
NXIOCB	TXA
	SEC
	SBC	#$10
	TAX
	BPL	IIO1
	LDX	#0	;REOPEN IOCB0 to E:
	LDA	#OPEN
	STA	ICCOM
	LDA	#ECL
	STA	ICBAL
	LDA	#ECH
	STA	ICBAH
	LDA	#$C
	STA	ICAX1,X
	JMP	CIO
	;RTS
EC	.BYTE	"E:",CR
	;HILO	EC
ECH	=	EC/256
ECL	=	-256*ECH+EC
;
;
GETLIN	LDA	#CR
	LDX	#79
	STA	LINE,X
	DEX
	BPL	*-4
	LDA	#0
	STA	PTR
	STA	IPTR
	STA	PER_
	JSR	CIOGET
	JMP	SCROL
	;RTS
;
;
;
; CIOGET - GET LINE OF INPUT FROM SCREEN EDITOR
;
CIOGET	LDA	#GETRCD+TEXT
	STA	ICCOM	;SCREEN EDIT IOCB
	LDA	#LBUFL
	STA	ICBAL
	LDA	#LBUFH
	STA	ICBAH

	LDA	#80
	STA	ICBLL
	LDA	#0	;[could use ASL A to save a byte here]
	STA	ICBLH
	LDX	#0	;[could use TAX to save a byte here]
	JSR	CIO	;READ RECORD FROM SCREEN EDITOR
	CPY	#$80	;CHECK FOR BREAK ABORT STATUS
	BNE	*+5
	DEC	PER_	;PARAM ERROR FLAG IS SET IF SO
	RTS
CHRGET	LDA	#0
	STA	PER_
CHRG1	JSR	CIOGET	;GET A LINE FROM E:
	LDA	ICBLL	;SAVE CHAR COUNT
	STA	RCNT
	JSR	SCROL
	LDA	PER_
	BPL	CHRG2	;IF BREAK, CLOSE AND EXIT
	JSR	CLOSX
PERX1	=*
	JMP	MENUSL
CHRG2	LDA	RCNT	;EXPECT 1 OR 2 CHARACTERS
	CMP	#3
	BMI	CHRG3	;IF OK
	LDA	#OLL
	LDX	#OLH
	JSR	DSPLIN
	JMP	CHRG1	;TRY AGAIN
CHRG3	LDA	LINE	;GET 1ST CHAR
	RTS
OL	.BYTE	"PLEASE TYPE 1 LETTER",CR
	;HILO	OL
OLH	=	OL/256
OLL	=	-256*OLH+OL
;
; PERX - EXIT IF PARAMETER ERRORS
;
PERX	BIT	PER_
	BMI	PERX1
	RTS
;
; GETCLI - READ LINE, GET FILENAME, POINT TO IT IN IOCB1
;
; [bottom of page cut off in listing]
GETICI	JSR	GETLIN
	LDX	#$10
	JSR	PIOCB
	JMP	GETFIL
	;RTS

;
;
GETNAME	LDA	#8
	STA	CTR
	LDY	PTR
	LDX	IPTR
	JMP	CFTE
;
;
;GET FILESPEC FROM INPUT LINE
GETFIL	LDY	PTR
	LDX	IPTR
	LDA	#$0B	;[Dissasembly has #$0B, listing as #10.  Which is correct?]
	STA	CTR
;AVOID GETTING JUNK ON VERY SHORT PARAMS
	LDA	LINE,X
	CMP	#","
	BEQ	ADDC
	CMP	#CR
	BEQ	ADDC
	LDA	LINE+1,X
	CMP	#","
	BEQ	GT1
	CMP	#CR
	BEQ	GT1
	LDA	#":"	;LOOK FOR : IN FILESPEC
	CMP	LINE+2,X	;SEE IF HAVE COMPLETE FILESPEC ALREADY
	BEQ	CFTE
	CMP	LINE+1,X
	BNE	GT1
	DEC	CTR
	LDA	LINE,X
	CMP	#"A"
	BPL	CFTE	;HAVE X:FILE, COMPLETE FILESPEC
;IF FALLS THRU, IS UNIT:FILE, ADD D
GT2	LDA	#"D"
	STA	PAR,Y
	INY
	BPL	CFTE
GT1	DEC	CTR
	CMP	LINE,X	;AN UNLIKELY CASE (:FILE)
	BEQ	GT2	;TREAT :FILE AS D:FILE
	DEC	CTR
ADDC	LDA	#"D"
	STA	PAR,Y
	INY
	LDA	#":"
	STA	PAR,Y
	INY
CFTE	LDA	#0
	STA	OPT
CFTE1	LDA	LINE,X
	STA	PAR,Y
	INX
	INY
	CMP	#CR	;LOOK FOR TERMINATION
	BEQ	EOC
	CMP	#","
	BEQ	EOC
	CMP	#"0"-1

	BEQ	POPT
	CMP	#"."	;LOOK FOR START OF .EXT
	BNE	CFTE2
	LDA	#4	;FOUND, 4 MORE CHARS MAX
	STA	CTR
CFTE2	DEC	CTR
	BPL	CFTE1
;GETS HERE IF TOO MANY CHARS IN FILENAME
	LDA	#NTLL
	LDX	#NTLH
	JSR	DSPLIN	;NAME TOO LONG
	DEC	PER_	;SET PARAMETER ERROR FLAG
STE	LDA	LINE,X  SKIP TO END
	INX
	CMP	#","
	BEQ	EOC
	CMP	#CR
	BNE	STE
EOC	STX	IPTR
	STY	PTR
	RTS
POPT	LDA	LINE,X
	STA	OPT
	INX
	LDA	LINE,X
	STA	PAR-1,Y CHANGE STORED TERMINATOR TO , OR CR I HOPE
	INX
	BPL	EOC
NTL	.BYTE	"NAME TOO LONG",CR
	;HILO	NTL
NTLH	=	NTL/256
NTLL	=	-256*NTLH+NTL
;
; DSPMSG - DISPLAY N BYTES
;	BUFFER POINTER AND LENGTH ARE ALREDY IN IOCB0
;
DSPMSG	LDA	#PUTCHR
	STA	ICCOM
	LDX	#0
	JMP	CIO1
	;RTS
;
; DSPLIN - DISPLAY ONE LINE OF TEXT
;
DSPLIN	JSR	DSPLI1
	JMP	SCROL
	;RTS
;
;
DSPLI1	STA	ICBAL	;ADDRESS OF LINE TO IOCB
	STX	ICBAH
	LDA	#PUTRCD+TEXT
	STA	ICCOM
	LDA	#0	;SET BUFF LEN
	STA	ICBLH
	LDA	#80

	STA	ICBLL
	LDX	#0
	JMP	CIO1
	;RTS
;
CIO1	JSR	CIO	;CALL CIO AND GO TO MENUSL
	CPY	#$80	;IF BREAK KEY ABORT
	BEQ	DOMENUSL
	RTS
;
; SCROL - DO SCROLLING OF AREA BELOW MENU
;
SCROL	LDA	#0
	TAX
	STA	ICBLH,X
	LDA	#10
	STA	ICBLL,X
	LDA	#ZAPH
	STA	ICBAH,X
	LDA	#ZAPL
	STA	ICBAL,X
	JMP	DSPMSG
	;RTS
ZAP	.BYTE	CUP,CUP,CUP,CUP,CUP
	.BYTE	DLL,CDN,CDN,CDN,CDN
	;HILO	ZAP
ZAPH	=	ZAP/256
ZAPL	=	-256*ZAPH+ZAP
;
; PIOCB - POINT IOCB AT PAR(PTR)
;
PIOCB	LDA	#PARL
	CLC
	ADC	PTR
	STA	ICBAL,X
	LDA	#PARH
	ADC	#0
	STA	ICBAH,X
	RTS
;
; CIOCL - CALL CIO AND PROCESS ANY ERRORS
;
CIOCL	JSR	CIO	;CALL CIO
	TYA
	BMI	CIOER1	; was: *+3
	RTS		;OK, RETURN
CIOER1	TYA		;ERROR STATUS
CIOER	SEC
	SBC	#100	;ERROR NUMS ALWAYS ARE 1XX DEC
	LDX	#"0"-1
CTNS	INX
	SEC
	SBC	#10
	BPL	CTNS	;THE EASY (SLOW) WAY
	CLC
	ADC	#10+"0"	;CONVERT
	STA	EUN

	STX	ETN
	LDX	#CIEH
	LDA	#CIEL
CIEX	JSR	DSPLIN
	JSR	CLOSX	;CLOSE IOCBS 10,20
DOMENUSL =*		; could be any JMP MENUSL in range
	JMP	MENUSL
CIE	.BYTE	"ERROR-   1"
ETN	.BYTE	0	;[In disassembly, '2, as it will change in use]
EUN	.BYTE	0	;[In disassembly, '8, as it will change in use]
	.BYTE	CR
	;HILO	CIE
CIEH	=	CIE/256
CIEL	=	-256*CIEH+CIE
;
; CLOSX - CLOSE IOCBS 10,20
;
CLOSX	LDA	#CLOSE
	STA	ICCOM+$10
	STA	ICCOM+$20
	LDX	#$10
	JSR	CIO
	LDX	#$20
	JMP	CIO
	;RTS
	;.IF	SYSRES
;
;
; LOAD - THIS SUBROUTINE
;	   LOADS FROM THE FILE (MUST BE LOAD FORMAT)
;	   INTO MEMORY, RETURNS:
;	 X=0 LOAD OK
;	 X=1 OPEN ERRORS Y=CIO CODE
;	 X=2 READ ERRORS Y=CIO CODE
;	 X=3 BAD LOAD FILE
; ON ENTRY, IOCB 1 POINTS TO FILENAME.
;
LOAD	LDA	#LRTS&255	; Set default run address to an RTS instruction
	STA	RUNAD
	LDA	#LRTS/256
	STA	RUNAD+1
	LDX	#$10
	LDA	#OPEN
	STA	ICCOM,X
	LDA	#4	;OPEN TYPE=INPUT
	STA	ICAX1,X
	JSR	CIO	;TRY TO OPEN FILE
	BPL	RDLF
	LDA	#1
	BNE	CLFX	;CLOSE AND EXIT
RDLF	LDX	#$10
	LDA	#DBUFL
	STA	ICBAL,X
	LDA	#DBUFH
	STA	ICBAH,X
	LDA	#2
	STA	ICBLL,X
	LDA	#0
	STA	ICBLH,X
	LDA	#GETCHR
	STA	ICCOM,X
	JSR	CIO

	BMI	ERST	;IF ERRS
	LDA	#$84
	CMP	DBUF	;CHECK FOR VALID LOAD FILE
	BNE	LNLF
	LDA	#$09
	CMP	DBUF+1
	BNE	LNLF
RDDRC	LDX	#$10
	LDA	#DBUFL
	STA	ICBAL,X
	LDA	#DBUFH
	STA	ICBAH,X
	LDA	#4
	STA	ICBLL,X
	LDA	#0
	STA	ICBLH,X
	JSR	CIO	;NO ERROR CHECK SO CAN CATCH EOF
	BPL	STOK	;IF NO ERROR
	CPY	#$88	;SEE IF EOF
	BNE	ERST	;IF SOME ERROR STATUS
;EOF SO DONE, EXIT
	LDA	#0
CLFX	PHA
	TYA
	PHA
	LDX	#$10
	LDA	#CLOSE
	STA	ICCOM,X
	JSR	CIO
	PLA
	TAY
	PLA
	TAX
	BNE	LRTS	; if A and X are now zero, then success, otherwise some error
	JMP	(RUNAD)	; set to LRTS above
LRTS	RTS
LNLF	LDA	#3	;BAD LOAD FILE
	BNE	CLFX
ERST	LDA	#2	;READ ERRS
	BNE	CLFX
STOK	LDX	#$10
	LDA	DBUF	;MOVE PARAMS TO IOCB
	STA	ICBAL,X
	LDA	DBUF+1
	STA	ICBAH,X
	LDA	DBUF+2
	SEC
	SBC	DBUF
	STA	ICBLL,X
	LDA	DBUF+3
	SBC	DBUF+1
	STA	ICBLH,X
	INC	ICBLL,X
	BNE	*+5
	INC	ICBLH,X
	JSR	CIO
	BMI	ERST
	JMP	RDDRC
	;.ENDIF
;
;
; [comment is on truncated line]
;	   RETURN A=LO, X=HI. PER SET MINUS IF ERROR.
;	   INC IPTR PAST PARAM
;
GETNO	LDA	#4	;MAX NO DIGITS
	STA	CTR
	LDA	#0
	STA	T1
	STA	T1+1	;INIT TEMP TO BUILD NUMBER IN
GHS	LDX	IPTR
	LDA	LINE,X  GET CHAR
	INC	IPTR
	CMP	#CR	;SEE OF TERMINATOR
	BEQ	GND
	CMP	#","
	BEQ	GND
	JSR	HEXCON	;CONVERT ASCII TO NIBBLE
	BMI	ERRX	;IF ERROR
	LDY	#3	;SHIFT T1,T1+1 by 4
SHT1	;CLC
	ASL	T1+1	;was: ROL
	ROL	T1
	DEY
	BPL	SHT1
	ORA	T1+1	;OR IN NEW NIBBLE
	STA	T1+1
	DEC	CTR	;COUNT DIGIT
	BPL	GHS	;LOOP UNLESS TOO MANY DIGITS
	LDA	#TMDL
	LDX	#TMDH
ERRX1	JSR	DSPLIN
	DEC	PER_
	RTS
GND	LDA	T1+1
	LDX	T1
	RTS
ERRX	LDA	#IHPL	;INVALID HEX PARAM
	LDX	#IHPH
	BNE	ERRX1
TMD	.BYTE	"TOO MANY DIGITS",CR
	;HILO	TMD
TMDH	=	TMD/256
TMDL	=	-256*TMDH+TMD
IHP	.BYTE	"INVALID HEXADECIMAL PARAMETER",CR
	;HILO	IHP
IHPH	=	IHP/256
IHPL	=	-256*IHPH+IHP

;
;
; HEXCON - CONVERT ASCII CHAR IN A TO HEX NIBBLE IN A. RETURN
;	    MINUS CONDITION, A=FF IF ERROR.
;
HEXCON	SEC
	SBC	#"0"
	BMI	ERRX2
	CMP	#10
	BMI	OKX	;0-9 CONVERTED SO EXIT
	SEC
	SBC	#"A"-"0"-10
	CMP	#10	;CONVERTED VALUE MUST BE 10 OR MORE
	BMI	ERRX2	;BETWEEN '9' AND 'A'
	CMP	#$10
	BMI	OKX	;A-F CCONVERTED
ERRX2	LDA	#$FF
OKX	CMP	#0	;SET STATUS BY VALUE IN A
	RTS

;
;	GETDN - GET A DEVICE NUMBER FROM LINE(IPTR)
;	 RETURN IT IN A
;
GETDN	BIT	PER_	;SEE IF PARAM ERROR ALREADY
	BMI	GDR	;IF SO DONT BOTHER
	LDX	IPTR
GETD	LDA	LINE,X
	INX
	CMP	#"D"	;IF DN
	BEQ	GETD	;GO GET DIGIT
	SEC
	SBC	#"0"	;CONVERT DIGIT
	BEQ	BDS	;CANT BE ZERO
	BMI	BDS	;IF NOT DIGIT
	CMP	#5	;[hard-coded limit of 4 drives]
	BPL	BDS	;TOO LARGE
	PHA
GD1	LDA	LINE,X
	INX
	CMP	#","
	BEQ	GDX	;IF TERMINATOR
	CMP	#CR
	BNE	GD1	;KEEP LOOKING
GDX	STX	IPTR	;ADVANCE POINTER
	PLA
GDR	RTS
BDS	DEC	PER_
	LDA	#NDSL	;NEED DEVICE SPEC MSG
	LDX	#NDSH
	JMP	DSPLIN
	;RTS
NDS	.BYTE	"NEED D1 THRU D4",CR
	;HILO	NDS
NDSH	=	NDS/256
NDSL	=	-256*NDSH+NDS
;
; DRH - DEVICE REDIRECTION HANDLER
;
;	WHEN LOGICAL DEVICES ARE CREATED, THE HANDLER ADDRESS
;	POINTS HERE. THE DRH LOOKS UP THE PHYSICAL DEVICE SPEC
;	AT OPEN TIME AND CALLS THE APPROPRIATE HANDLER. THE IOCB
;	HANDLER ID IS THEN SET TO THAT HANDLER SO CIO CALLS AFTER
;	THE OPEN GO DIRECTLY TO THAT HANDLER.
;
DRH	=*
	;HILO	DRH
DRHH	=	DRH/256
DRHL	=	-256*DRHH+DRH
;
;	HANDLER VECTORS (ONLY OPEN IS USED)
;
	.WORD	EOPEN-1

;	.BYTE	0,0,0,0,0	;UNUSED [supposedly, but just in case]
;	RTS		;INIT ROUTINE [why have this here?]
;
EOPEN	LDY	#$00
	LDA	(ICBALZ),Y	;GET LOGICAL DEVICE NAME
	JSR	FLDB	;SEARCH LOG DEV NAME TABLE
	BPL	FLD	;IF FOUND IT OK
;INTERNAL ERROR IF WE GOT HERE
IERR	LDY	#$AC	;NEW ERROR
HERRX	RTS
FLD	TXA		;CREATE POINTER TO PHYSICAL DEVSPEC
	LDX	ICIDNO	;GET IOCB # (X cleared in FLDB)
	ASL		; A is PDST entry (0-4)
	ASL		; multiply by 16 to get offset into PDST
	ASL
	ASL
	ADC	#PDSTL
	;STA	ICBALZ
	STA	ICBAL,X	;FOR FMS
	LDA	#PDSTH
	ADC	#0	; not needed if PDST + 4*16 is still on the same page
	;STA	ICBAHZ
	STA	ICBAH,X	;FOR FMS
	JMP	CIO	; Just do CIO again to avoid XL issues. Simpler, too!
	;JSR	DEVSRC	;GO FIND PHYS DEVICE HID/DNO
	;BCS	HERRX	;IF ERRORS
	;LDA	ICDNOZ
	;STA	ICDNO,X	;FOR FMS
	;JSR	COMENT	;GET PHYS DEV HDLR OPEN ENTRY
	;BCS	HERRX
	;JMP	GOHAND	;GO DO REAL OPEN
	;RTS		;THATS ALL
	;.END
; [disassembly has 146 zeros at the end]
ENDCODE	= *
;
; Buffers for DUP that do not need to be saved with DOS.SYS
;
;PAR	*=*+40	;PARAMETER AREA [1329]
PAR	.WORD 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
PARH	=	PAR/256
PARL	=	-256*PARH+PAR
;LINE	*=*+80	;TYPEIN LINE BUFFER [1351]
LINE	.WORD 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
LBUFH	=	LINE/256
LBUFL	=	-256*LBUFH+LINE
;DBUF	*=*+$100	;DATA BUFFER FOR COPY
DBUF	.WORD	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	.WORD	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
DB1	.WORD	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	.WORD	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
;DB1	=	DBUF+$80
DB3	=	DBUF-3
	;HILO	DBUF
DBUFH	=	DBUF/256
DBUFL	=	-256*DBUFH+DBUF
	;HILO	DB1
DB1H	=	DB1/256
DB1L	=	-256*DB1H+DB1
	;HILO	DB3
DB3H	=	DB3/256
DB3L	=	-256*DB3H+DB3
DBLL	=	0
DBLH	=	1	;DATA BUFFER LENGTH=$100
MENUSZ	.BYTE 0
PER_	.BYTE 0
UNNO	.BYTE 0
RCNT	.BYTE 0
SSTAT	.BYTE 0
SWDP	.BYTE 0,0,0,0,0
CSRC	.BYTE 0
CDES	.BYTE 0
SAVX	.BYTE 0
PTR	.BYTE 0
IPTR	.BYTE 0
CTR	.BYTE 0
OPT	.BYTE 0
T1	.WORD 0
STVEC	.WORD 0	;A TEMP OF SOME KIND
MNA	.WORD 0	;MENU ADDRESS
MNL	.WORD 0	;MENU LENGTH
RDM	.BYTE 0	;FF TO REDISPLAY MENU
DTH	=*
	;HILO	DTH
DTHH	=	DTH/256
DTHL	=	-256*DTHH+DTH
LDST	.WORD 0
LDND	.WORD 0
LDNT	.BYTE	0,0,0,0,0	; defined device for each entry
;PDST	*=*+80		;;TABLE OF PHYSICAL DEV:FILESPECS
			; PDST is five 16-byte entries for I/O redirection targets
PDST	.WORD 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	;HILO	PDST
PDSTH	=	PDST/256
PDSTL	=	-256*PDSTH+PDST
; End of DUP buffers

;
; Buffers for DOS that do not need to be saved with DOS.SYS
;
ENTSTK	.byte	$F7
CURFCB	.byte	$10
DHOLES	.byte	$00
DHOLED	.byte	$00
DHFNUM	.byte	$00
CDIRD	.byte	$00
CDIRS	.byte	$00
SFNUM	.byte	$00
SVDBYT	.byte	$9B ; ''
TEMP1	.byte	$00
TEMP2	.byte	$05
TEMP3	.byte	$02
TEMP4	.byte	$80
DRVTBL	.byte	$03
	.byte	$02
	.byte	$01
	.byte	$00
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$FF
SECTBL	.byte	$00
	.byte	$00
	.byte	$80
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$FF
FNAME	.byte	"DOS     SYS "
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$04
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
L1157	.byte	$04
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
FCBFNO	.byte	$00
FCBOTC	.byte	$00
FCBSPR	.byte	$00
FCBSLT	.byte	$00
FCBFLG	.byte	$00
FCBMLN	.byte	$00
FCBDLN	.byte	$00
FCBBUF	.byte	$00
FCBCSN	.word	$0000
FCBLSN	.word	$0000
FCBSSN	.word	$0000
FCBCNT	.word	$0000
FCB1	.byte	$00
	.byte	$08
	.byte	$00
	.byte	$00
	.byte	$80
	.byte	$00
	.byte	$00
	.byte	$03
	.byte	$16
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$15
	.byte	$00
	.byte	$14
	.byte	$00
FCB2	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
FCB3	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
FCB4	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
FCB5	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
FCB6	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
FCB7	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
;
; DISK FILE DIRECTORY
; THE FILE DIRECTORY OCCUPIES 8
;CONSECUTIVE SECTORS STARTING AT THE
; CENTRAL SECTOR+1.  EACH FILE DIRECTORY
; SECTOR CONTAINS 8 ENTRIES.  THERE
; IS 1 ENTRY FOR EACH NAMED FILE.  THE
; THERE ARE A TOTAL OF 64 NAMED FILES
; PER VOLUME
;
; THE FILE NUMBER IS USED THROUGH THE 
; THE SYSTEM IS THE RELATIVE (TO ONE)
; FILE DIRECTORY ENTRY NUMBER.
;
; THE EQUATES BELOW ARE FOR A SINCE NAMED
; FILE ENTRY
;
DFDFL1	= 0	;FLAG1
DFDCNT	= 1	;SECTOR COUNTER (LOW)
DFDSSN	= 3	;START SECTOR NO (2)
DFDPFN	= 5	;PRIMARY FILE NAME (8)
DFDXFN	= 13	;EXTENDED FILE NAME (4)
DFDLEN	= 16	;ENTRY LENGTH
;
; DFDFL1 VALUE EQUATES
;
DFDEUU	= 0	;ENTRY UNUSED
DFDEDE	= $80	;ENTRY DELETED
DFDINU	= $40	;ENTRY IN USE
DFDOUT	= $01	;FILE OPEN FOR OUTPUT
DFDLOC	= $20	;ENTRY LOCKED
;
FILDIR	.byte	$40 ; '@'
	.byte	$00
	.byte	$00
	.byte	$02
	.byte	$00
	.byte	$44 ; 'D'
	.byte	$4F ; 'O'
	.byte	$53 ; 'S'
	.byte	$20 ; ' '
	.byte	$20 ; ' '
	.byte	$20 ; ' '
	.byte	$20 ; ' '
	.byte	$20 ; ' '
	.byte	$53 ; 'S'
	.byte	$59 ; 'Y'
	.byte	$53 ; 'S'
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$01
	.byte	$C5
	.byte	$02
	.byte	$AC
	.byte	$02
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$7F
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$9F
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$00
	.byte	$7F
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$00
	.byte	$00
	.byte	$FD
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
; End of DOS buffers
ENDPRG = * ;$2680
